<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Talend Component Documentation :: Talend Component Kit Developer Reference Guide</title>
    <link rel="canonical" href="https://talend.github.io/component-runtime/main/1.0.0/documentation.html">
    <link rel="stylesheet" href="../../_/css/site.css">
<meta name="date" content="2018-02-22T14:20:54.673Z" scheme="YYYY-MM-DDTHH:mm:ss.sssZ">
<link rel="stylesheet" href="../../_/css/talend.css">
<link rel="shortcut icon" href="../../_/images/favicon_0.ico" />    <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-PSBN"></script>
    <script>function gtag(){$gtag.push(arguments)}$gtag=window.dataLayer||[],gtag("js",new Date),gtag("config","GTM-PSBN");</script>
  </head>
  <body class="article">
<header class="header" role="banner">
    <nav class="navbar">
        <div class="navbar-brand">
            <div class="navbar-item">
                <a href="https://talend.github.io/component-runtime">Talend Component Kit</a>
                <span class="separator">//</span>
                <a href="https://talend.github.io/component-runtime">Docs</a>
            </div>
            <button class="navbar-burger" data-target="topbar-nav">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
        <div id="topbar-nav" class="navbar-menu">
            <div class="navbar-end">
                <div class="global-search">
                    <form role="search" action="search.html">
                        <div>
                            <input type="text" placeholder="Search" name="q">
                        </div>
                    </form>
                </div>
                <div class="navbar-item has-dropdown is-hoverable">
                    <div class="navbar-link">Projects</div>
                    <div class="navbar-dropdown">
                        <div class="navbar-item"><strong>API</strong></div>
                        <a class="navbar-item" href="https://github.com/talend/component-api">Repository</a>
                        <hr class="navbar-divider">
                        <div class="navbar-item"><strong>Runtime</strong></div>
                        <a class="navbar-item" href="https://github.com/talend/component-rutime">Repository</a>
                    </div>
                </div>
            </div>
        </div>
    </nav>
</header>
<div class="main-wrapper">
<div class="navigation-container">
  <aside class="navigation" role="navigation">
    <div class="panels">
<div class="navigation-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">Talend Component Kit Developer Reference Guide</a></h3>
  </nav>
</div>
<div class="navigation-explore" data-panel="explore">
  <div class="current">
    <span class="title">Talend Component Kit Developer Reference Guide</span>
    <span class="version">1.0.0</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Talend Component Kit Developer Reference Guide</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">1.0.0</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
  <main class="main" role="main">
<div class="toolbar" role="navigation">
    <button class="navigation-toggle"></button>
    <nav class="crumbs" role="navigation" aria-label="breadcrumbs">
  <ul>
    <li class="crumb"><a href="index.html">Talend Component Kit Developer Reference Guide</a></li>
  </ul>
</nav>
    </div>
<article class="doc">
        <h1>Talend Component Documentation</h1>
        <div class="paragraph">
<p>&lt;div id="preamble"&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;div id="preamble"&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Talend Component framework relies on several primitive components.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;They can all use &lt;code&gt;@PostConstruct&lt;/code&gt; and &lt;code&gt;@PreDestroy&lt;/code&gt; to initialize/release
some underlying resource at the beginning/end of the processing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
in distributed environments class' constructor will be called on cluster manager node, methods annotated with
&lt;code&gt;@PostConstruct&lt;/code&gt; and &lt;code&gt;@PreDestroy&lt;/code&gt; annotations will be called on worker nodes. Thus, partition plan computation and pipeline task
will be performed on different nodes.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;span class="image"&gt;&lt;img src="_images/deployment-diagram.png" alt="deployment diagram"&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="olist arabic"&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;
&lt;p&gt;Created task consists of Jar file, containing class, which describes pipeline(flow) which should be processed in cluster.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;During partition plan computation step pipeline is analyzed and split into stages. Cluster Manager node instantiates mappers/processors
gets estimated data size using mappers, splits created mappers according to the estimated data size. All instances are serialized and
sent to Worker nodes afterwards.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Serialized instances are received and deserialized, methods annotated with @PostConstruct annotation are called. After that,
pipeline execution is started. Processor&#8217;s @BeforeGroup annotated method is called before processing first element in chunk.
After processing number of records estimated as chunk size, Processor&#8217;s @AfterGroup annotated method called. Chunk size is calculated
depending on environment the pipeline is processed by. After pipeline is processed, methods annotated with @PreDestroy annotation are called.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;span class="image"&gt;&lt;img src="_images/driver-processing-workflow.png" alt="driver processing workflow"&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;span class="image"&gt;&lt;img src="_images/worker-processing-workflow.png" alt="worker processing workflow"&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
all framework managed methods &lt;code&gt;MUST&lt;/code&gt; be public too. Private methods are ignored.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="admonitionblock note"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-note" title="Note"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
in term of design the framework tries to be as declarative as possible but also to stay extensible
not using fixed interfaces or method signatures. This will allow to add incrementally new features of the underlying implementations.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_partitionmapper"&gt;&lt;a class="anchor" href="#_partitionmapper"&gt;&lt;/a&gt;1. PartitionMapper&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="quoteblock"&gt;
&lt;blockquote&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A &lt;code&gt;PartitionMapper&lt;/code&gt; is a component able to split itself to
make the execution more efficient.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This concept is borrowed to big data world and useful only in this context (&lt;code&gt;BEAM&lt;/code&gt; executions).
Overall idea is to divide the work before executing it to try to reduce the overall execution time.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The process is the following:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="olist arabic"&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;
&lt;p&gt;Estimate the size of the data you will work on. This part is often heuristic and not very precise.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From that size the execution engine (&lt;em&gt;runner&lt;/em&gt; for beam) will request the mapper to split &lt;em&gt;itself&lt;/em&gt; in &lt;em&gt;N&lt;/em&gt; mappers with a subset of the overall work.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;em&gt;leaf&lt;/em&gt; (final) mappers will be used as a &lt;code&gt;Producer&lt;/code&gt; (actual reader) factory.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
this kind of component &lt;code&gt;MUST&lt;/code&gt; be &lt;code&gt;Serializable&lt;/code&gt; to be distributable.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_definition"&gt;&lt;a class="anchor" href="#_definition"&gt;&lt;/a&gt;2. Definition&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A partition mapper requires 3 methods marked with specific annotations:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="olist arabic"&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Assessor&lt;/code&gt; for the evaluating method&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Split&lt;/code&gt; for the dividing method&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Emitter&lt;/code&gt; for the &lt;code&gt;Producer&lt;/code&gt; factory&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_assessor"&gt;&lt;a class="anchor" href="#_assessor"&gt;&lt;/a&gt;2.1. @Assessor&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The assessor method will return the estimated size of the data related to the component (depending its configuration).
It &lt;code&gt;MUST&lt;/code&gt; return a &lt;code&gt;Number&lt;/code&gt; and &lt;code&gt;MUST&lt;/code&gt; not take any parameter.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Assessor
public long estimateDataSetByteSize() {
    return &#8230;&#8203;.;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_split"&gt;&lt;a class="anchor" href="#_split"&gt;&lt;/a&gt;2.2. @Split&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The split method will return a collection of partition mappers and can take optionally a &lt;code&gt;@PartitionSize&lt;/code&gt; long
value which is the requested size of the dataset per sub partition mapper.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Split
public List&lt;MyMapper&gt; split(@PartitionSize final long desiredSize) {
    return &#8230;&#8203;.;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_emitter"&gt;&lt;a class="anchor" href="#_emitter"&gt;&lt;/a&gt;2.3. @Emitter&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The emitter method &lt;code&gt;MUST&lt;/code&gt; not have any parameter and &lt;code&gt;MUST&lt;/code&gt; return a producer. It generally uses the partition mapper configuration
to instantiate/configure the producer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Emitter
public MyProducer create() {
    return &#8230;&#8203;.;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_producer"&gt;&lt;a class="anchor" href="#_producer"&gt;&lt;/a&gt;3. Producer&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="quoteblock"&gt;
&lt;blockquote&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A &lt;code&gt;Producer&lt;/code&gt; is the component interacting with a physical source. It produces input data for the processing flow.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A producer is a very simple component which &lt;code&gt;MUST&lt;/code&gt; have a &lt;code&gt;@Producer&lt;/code&gt; method without any parameter and returning any data:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Producer
public MyData produces() {
    return &#8230;&#8203;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_processor"&gt;&lt;a class="anchor" href="#_processor"&gt;&lt;/a&gt;4. Processor&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="quoteblock"&gt;
&lt;blockquote&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A &lt;code&gt;Processor&lt;/code&gt; is a component responsible to convert an incoming data to another model.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A processor &lt;code&gt;MUST&lt;/code&gt; have a method decorated with &lt;code&gt;@ElementListener&lt;/code&gt; taking an incoming data and returning the processed data:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@ElementListener
public MyNewData map(final MyData data) {
    return &#8230;&#8203;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
this kind of component &lt;code&gt;MUST&lt;/code&gt; be &lt;code&gt;Serializable&lt;/code&gt; since it is distributed.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
if you don&#8217;t care much of the type of the parameter and need to access data on a "map like" based rule set, then you can
use &lt;code&gt;JsonObject&lt;/code&gt; as parameter type and Talend Component will just wrap the data to enable you to access it as a map. The parameter
type is not enforced, i.e. if you know you will get a &lt;code&gt;SuperCustomDto&lt;/code&gt; then you can use that as parameter type but for generic
component reusable in any chain it is more than highly encouraged to use &lt;code&gt;JsonObject&lt;/code&gt; until you have your an evaluation language
based processor (which has its own way to access component). Here is an example:
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@ElementListener
public MyNewData map(final JsonObject incomingData) {
    String name = incomingData.getString("name");
    int name = incomingData.getInt("age");
    return &#8230;&#8203;;
}&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;public class Person {
    private String age;
    private int age;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="literalblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;    // getters/setters
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;@ElementListener
public MyNewData map(final Person person) {
    String name = person.getName();
    int name = person.getAge();
    return &#8230;&#8203;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A processor also supports &lt;code&gt;@BeforeGroup&lt;/code&gt; and &lt;code&gt;@AfterGroup&lt;/code&gt; which &lt;code&gt;MUST&lt;/code&gt; be methods without parameters and returning &lt;code&gt;void&lt;/code&gt; (result would be ignored).
This is used by the runtime to mark a chunk of the data in a way which is estimated &lt;em&gt;good&lt;/em&gt; for the execution flow size.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
this is estimated so you don&#8217;t have any guarantee on the size of a &lt;em&gt;group&lt;/em&gt;. You can literally have groups of size 1.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The common usage is to batch records for performance reasons:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@BeforeGroup
public void initBatch() {
    // &#8230;&#8203;
}&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;@AfterGroup
public void endBatch() {
    // &#8230;&#8203;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
it is a good practise to support a &lt;code&gt;maxBatchSize&lt;/code&gt; here and potentially commit before the end of the group in case
of a computed size which is way too big for your backend.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_multiple_outputs"&gt;&lt;a class="anchor" href="#_multiple_outputs"&gt;&lt;/a&gt;5. Multiple outputs&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In some case you may want to split the output of a processor in two. A common example is "main" and "reject" branches
where part of the incoming data are put in a specific bucket to be processed later.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This can be done using &lt;code&gt;@Output&lt;/code&gt;. This can be used as a replacement of the returned value:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@ElementListener
public void map(final MyData data, @Output final OutputEmitter&lt;MyNewData&gt; output) {
    output.emit(createNewData(data));
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Or you can pass it a string which will represent the new branch:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@ElementListener
public void map(final MyData data,
                @Output final OutputEmitter&lt;MyNewData&gt; main,
                @Output("rejected") final OutputEmitter&lt;MyNewDataWithError&gt; rejected) {
    if (isRejected(data)) {
        rejected.emit(createNewData(data));
    } else {
        main.emit(createNewData(data));
    }
}&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;@ElementListener
public MyNewData map(final MyData data,
                    @Output("rejected") final OutputEmitter&lt;MyNewDataWithError&gt; rejected) {
    if (isSuspicious(data)) {
        rejected.emit(createNewData(data));
        return createNewData(data); // in this case we continue the processing anyway but notified another channel
    }
    return createNewData(data);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_multiple_inputs"&gt;&lt;a class="anchor" href="#_multiple_inputs"&gt;&lt;/a&gt;6. Multiple inputs&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Having multiple inputs is closeto the output case excep it doesn&#8217;t require a wrapper &lt;code&gt;OutputEmitter&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@ElementListener
public MyNewData map(@Input final MyData data, @Input("input2") final MyData2 data2) {
    return createNewData(data1, data2);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;@Input&lt;/code&gt; takes the input name as parameter, if not set it uses the main (default) input branch.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
due to the work required to not use the default branch it is recommanded to use it when possible and not
name its branches depending on the component semantic.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_output"&gt;&lt;a class="anchor" href="#_output"&gt;&lt;/a&gt;7. Output&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="quoteblock"&gt;
&lt;blockquote&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;An &lt;code&gt;Output&lt;/code&gt; is a &lt;code&gt;Processor&lt;/code&gt; returning no data.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Conceptually an output is a listener of data. It perfectly matches the concept of processor. Being the last of the execution chain
or returning no data will make your processor an output:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@ElementListener
public void store(final MyData data) {
    // &#8230;&#8203;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_combiners"&gt;&lt;a class="anchor" href="#_combiners"&gt;&lt;/a&gt;8. Combiners?&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For now Talend Component doesn&#8217;t enable you to define a &lt;code&gt;Combiner&lt;/code&gt;. It would be the symmetric part of the partition mapper
and allow to aggregate results in a single one.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;div id="preamble"&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Component are configured through their constructor parameters. They can all be marked with &lt;code&gt;@Option&lt;/code&gt;
which will let you give a name to parameters (if not it will use the bytecode name which can require you to compile with &lt;code&gt;-parameter&lt;/code&gt; flag
to not have &lt;code&gt;arg0&lt;/code&gt;, &lt;code&gt;arg1&lt;/code&gt;, &#8230;&#8203; as names).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The parameter types can be &lt;em&gt;primitives&lt;/em&gt; or complex objects with fields decorated with &lt;code&gt;@Option&lt;/code&gt; exactly like method parameters.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
it is recommanded to use simple models which can be serialized by components to avoid headaches when implementing serialized components.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;class FileFormat implements Serializable {
    @Option("type")
    private FileType type = FileType.CSV;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="literalblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;    @Option("max-records")
    private int maxRecords = 1024;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;@PartitionMapper(family = "demo", name = "file-reader")
public MyFileReader(@Option("file-path") final File file,
                    @Option("file-format") final FileFormat format) {
    // &#8230;&#8203;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Using this kind of API makes the configuration extensible and component oriented letting the user define all he needs.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The instantiation of the parameters is done from the properties passed to the component (see next part).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_primitives"&gt;&lt;a class="anchor" href="#_primitives"&gt;&lt;/a&gt;1. Primitives&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;What is considered as a primitive in this mecanism is a class which can be directly converted from a &lt;code&gt;String&lt;/code&gt; to the expected type.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It obviously includes all java primitives, &lt;code&gt;String&lt;/code&gt; type itself but also all the types with a &lt;code&gt;org.apache.xbean.propertyeditor.Converter&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This includes out of the box:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BigInteger&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;File&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;InetAddress&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ObjectName&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;URL&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Pattern&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_complex_object_mapping"&gt;&lt;a class="anchor" href="#_complex_object_mapping"&gt;&lt;/a&gt;2. Complex object mapping&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The conversion from properties to object is using the dotted notation. For instance:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-properties hljs" data-lang="properties"&gt;file.path = /home/user/input.csv
file.format = CSV&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;will match&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public class FileOptions {
    @Option("path")
    private File path;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="literalblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;    @Option("format")
    private Format format;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;assuming the method parameter was configured with &lt;code&gt;@Option("file")&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_list_case"&gt;&lt;a class="anchor" href="#_list_case"&gt;&lt;/a&gt;2.1. List case&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Lists use the same syntax but to define their elements their rely on an indexed syntax. Assuming the list parameter is named &lt;code&gt;files&lt;/code&gt;
and the elements are of  &lt;code&gt;FileOptions&lt;/code&gt; type, here is how to define a list of 2 elements:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-properties hljs" data-lang="properties"&gt;files[0].path = /home/user/input1.csv
files[0].format = CSV
files[1].path = /home/user/input2.xml
files[2].format = EXCEL&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_map_case"&gt;&lt;a class="anchor" href="#_map_case"&gt;&lt;/a&gt;2.2. Map case&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Inspired from the list case, the map uses &lt;code&gt;.key[index]&lt;/code&gt; and &lt;code&gt;.value[index]&lt;/code&gt; to represent its key and values:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-properties hljs" data-lang="properties"&gt;// Map&amp;lt;String, FileOptions&amp;gt;
files.key[0] = first-file
files.value[0].path = /home/user/input1.csv
files.value[0].type = CSV
files.key[1] = second-file
files.value[1].path = /home/user/input2.xml
files.value[1].type = EXCEL&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-properties hljs" data-lang="properties"&gt;// Map&amp;lt;FileOptions, String&amp;gt;
files.key[0].path = /home/user/input1.csv
files.key[0].type = CSV
files.value[0] = first-file
files.key[1].path = /home/user/input2.xml
files.key[1].type = EXCEL
files.value[1] = second-file&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
don&amp;#8217;t abuse of map type. If not needed for your configuration (= if you can configure your component
with an object) don&amp;#8217;t use it.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_constraints_and_validation_on_the_configuration_input"&gt;&lt;a class="anchor" href="#_constraints_and_validation_on_the_configuration_input"&gt;&lt;/a&gt;3. Constraints and validation on the configuration/input&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is common to need to add as metadata a field is required, another has a minimum size etc. This is done with the
validation in &lt;code&gt;org.talend.sdk.component.api.configuration.constraint&lt;/code&gt; package:&lt;/p&gt;
&lt;/div&gt;
&lt;table class="tableblock frame-all grid-all table-striped table-hover table-ordered"&gt;
&lt;colgroup&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class="tableblock halign-left valign-top"&gt;API&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Name&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Parameter Type&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Description&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Supported Types&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Metadata sample&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.constraint.Max&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;maxLength&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;double&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Ensure the decorated option size is validated with a higher bound.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;CharSequence&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"validation::maxLength":"12.34"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.constraint.Min&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;minLength&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;double&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Ensure the decorated option size is validated with a lower bound.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;CharSequence&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"validation::minLength":"12.34"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.constraint.Pattern&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;pattern&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;string&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Validate the decorated string with a java pattern, you can use xregex library in javascript.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;CharSequence&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"validation::pattern":"test"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.constraint.Max&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;max&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;double&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Ensure the decorated option size is validated with a higher bound.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Number, int, short, byte, long, double, float&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"validation::max":"12.34"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.constraint.Min&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;min&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;double&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Ensure the decorated option size is validated with a lower bound.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Number, int, short, byte, long, double, float&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"validation::min":"12.34"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.constraint.Required&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;required&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Mark the field as being mandatory.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Object&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"validation::required":"true"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.constraint.Max&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;maxItems&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;double&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Ensure the decorated option size is validated with a higher bound.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Collection&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"validation::maxItems":"12.34"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.constraint.Min&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;minItems&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;double&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Ensure the decorated option size is validated with a lower bound.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Collection&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"validation::minItems":"12.34"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.constraint.Uniques&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;uniqueItems&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Ensure the elements of the collection must be distinct (kind of set).&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Collection&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"validation::uniqueItems":"true"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
using the programmatic API the metadata are prefixed by &lt;code&gt;tcomp::&lt;/code&gt; but this prefix is stripped in the web for convenience,
the previous table uses the web keys.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_marking_a_configuration_as_a_particular_type_of_data"&gt;&lt;a class="anchor" href="#_marking_a_configuration_as_a_particular_type_of_data"&gt;&lt;/a&gt;4. Marking a configuration as a particular type of data&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is common to classify the incoming data. You can see it as tagging them in several types. The most common ones
are the:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;datastore: all the data you need to connect to the backend&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dataset: a datastore coupled with all the data you need to execute an action&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;table class="tableblock frame-all grid-all table-striped table-hover table-ordered"&gt;
&lt;colgroup&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class="tableblock halign-left valign-top"&gt;API&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Type&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Description&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Metadata sample&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;org.talend.sdk.component.api.configuration.type.DataSet&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;dataset&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Mark a model (complex object) as being a dataset.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"tcomp::configurationtype::type":"dataset","tcomp::configurationtype::name":"test"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;org.talend.sdk.component.api.configuration.type.DataStore&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;datastore&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Mark a model (complex object) as being a datastore (connection to a backend).&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"tcomp::configurationtype::type":"datastore","tcomp::configurationtype::name":"test"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
the component family associated with a configuration type (datastore/dataset) is always the one related
to the component using that configuration.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Those configuration types can be composed to provide one configuration item. For example a dataset type will often need a datastore
type to be provided. and a datastore type (that provides the connection information) will be used to create a dataset type.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Those configuration types will also be used at design time to create shared configuration that can be stored and used at runtime.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For example, we can think about a relational database that support JDBC:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A datastore may provide:&lt;/p&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;jdbc url, username, password&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A dataset may be:&lt;/p&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;datastore (that will provide the connection data to the database)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;table name, data []&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The component server will scan all those configuration types and provide a configuration type index. This index can be used for the integration
into the targeted platforms (studio, web applications&amp;#8230;&amp;#8203;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The configuration type index is represented as a flat tree that contains all the configuration types represented as nodes and indexed by their ids.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Also, every node can point to other nodes. This relation is represented as an array of edges that provide the childes ids.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For example, a configuration type index for the above example will be:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-json hljs" data-lang="json"&gt;{nodes: {
             "idForDstore": { datastore:"datastore data", edges:[id:"idForDset"] },
             "idForDset":   { dataset:"dataset data" }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_define_links_between_properties"&gt;&lt;a class="anchor" href="#_define_links_between_properties"&gt;&lt;/a&gt;5. Define links between properties&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It can be needed to define a binding between properties, a set of annotations allows to do it:&lt;/p&gt;
&lt;/div&gt;
&lt;table class="tableblock frame-all grid-all table-striped table-hover table-ordered"&gt;
&lt;colgroup&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class="tableblock halign-left valign-top"&gt;API&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Name&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Description&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Metadata Sample&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.condition.ActiveIf&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;if&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;If the evaluation of the element at the location matches value then the element is considered active, otherwise it is deactivated.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"condition::if::target":"test","condition::if::value":"value1,value2"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.condition.ActiveIfs&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;ifs&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Allows to set multiple visibility conditions on the same property.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"condition::if::value::0":"value1,value2","condition::if::value::1":"SELECTED","condition::if::target::0":"sibling1","condition::if::target::1":"../../other"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Target element location is specified as a relative path to current location using Unix path characters.
Configuration class delimiter is &lt;code&gt;/&lt;/code&gt;. Parent configuration class is specified by &lt;code&gt;..&lt;/code&gt;.
Thus &lt;code&gt;../targetProperty&lt;/code&gt; denotes a property, which is located in parent configuration class and has name &lt;code&gt;targetProperty&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
using the programmatic API the metadata are prefixed by &lt;code&gt;tcomp::&lt;/code&gt; but this prefix is stripped in the web for convenience,
the previous table uses the web keys.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="documentation-ui-hints"&gt;&lt;a class="anchor" href="#documentation-ui-hints"&gt;&lt;/a&gt;6. Add hints about the rendering based on configuration/component knowledge&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In some case it can be needed to add some metadata about the configuration to let the UI render properly the configuration.
A simple example is a password value must be hidden and not a simple clear input box. For these cases - when the component developper
wants to influence the UI rendering - you can use a particular set of annotations:&lt;/p&gt;
&lt;/div&gt;
&lt;table class="tableblock frame-all grid-all table-striped table-hover table-ordered"&gt;
&lt;colgroup&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class="tableblock halign-left valign-top"&gt;API&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Description&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Generated property metadata&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.ui.DefaultValue&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Provide a default value the UI can use - only for primitive fields.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"ui::defaultvalue::value":"test"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.ui.OptionsOrder&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Allows to sort a class properties.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"ui::optionsorder::value":"value1,value2"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.ui.layout.AutoLayout&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Request the rendered to do what it thinks is best.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"ui::autolayout":"true"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.ui.layout.GridLayout&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Advanced layout to place properties by row, this is exclusive with &lt;code&gt;@OptionsOrder&lt;/code&gt;.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"ui::gridlayout::value1::value":"first&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;second,third","ui::gridlayout::value2::value":"first&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;second,third"}&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.ui.layout.GridLayouts&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Allow to configure multiple grid layouts on the same class, qualified with a classifier (name)&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"ui::gridlayout::Advanced::value":"another","ui::gridlayout::Main::value":"first&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;second,third"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.ui.layout.HorizontalLayout&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Put on a configuration class it notifies the UI an horizontal layout is preferred.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"ui::horizontallayout":"true"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.ui.layout.VerticalLayout&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Put on a configuration class it notifies the UI a vertical layout is preferred.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"ui::verticallayout":"true"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.ui.widget.Code&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Mark a field as being represented by some code widget (vs textarea for instance).&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"ui::code::value":"test"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.ui.widget.Credential&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Mark a field as being a credential. It is typically used to hide the value in the UI.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"ui::credential":"true"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.ui.widget.Structure&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Mark a List&amp;lt;String&amp;gt; or Map&amp;lt;String, String&amp;gt; field as being represented as the component data selector (field names generally or field names as key and type as value).&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"ui::structure::type":"null","ui::structure::discoverSchema":"test","ui::structure::value":"test"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.configuration.ui.widget.TextArea&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Mark a field as being represented by a textarea(multiline text input).&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;{"ui::textarea":"true"}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
using the programmatic API the metadata are prefixed by &lt;code&gt;tcomp::&lt;/code&gt; but this prefix is stripped in the web for convenience,
the previous table uses the web keys.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="admonitionblock note"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-note" title="Note"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
target support should cover &lt;code&gt;org.talend.core.model.process.EParameterFieldType&lt;/code&gt; but we need to ensure web renderers is able to handle the same widgets.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_gallery"&gt;&lt;a class="anchor" href="#_gallery"&gt;&lt;/a&gt;1. Gallery&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_widgets"&gt;&lt;a class="anchor" href="#_widgets"&gt;&lt;/a&gt;1.1. Widgets&lt;/h3&gt;
&lt;table class="tableblock frame-all grid-all table gallery"&gt;
&lt;colgroup&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Name&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Code&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Studio Rendering&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Web Rendering&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Input/Text&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Option
String config;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/studio/input.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/studio/input.png" alt="Studio Input"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/web/input.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/web/input.png" alt="Web Input"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Password&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Option
@Credential
String config;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/studio/password.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/studio/password.png" alt="Studio Password"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/web/password.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/web/password.png" alt="Web Password"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Textarea&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Option
@Textarea
String config;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/studio/textarea.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/studio/textarea.png" alt="Studio Textarea"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/web/textarea.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/web/textarea.png" alt="Web Textarea"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Checkbox&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Option
Boolean config;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/studio/checkbox.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/studio/checkbox.png" alt="Studio Checkbox"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/web/checkbox.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/web/checkbox.png" alt="Web Checkbox"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;List&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Option
List&lt;String&gt; config;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/studio/list.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/studio/list.png" alt="Studio List"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/web/list.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/web/list.png" alt="Web List"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Table&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Option
Object config;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/studio/table.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/studio/table.png" alt="Studio Table"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/web/table.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/web/table.png" alt="Web Table"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Code&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Code("java")
@Option
String config;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/studio/javaCode.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/studio/javaCode.png" alt="Studio Code"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/web/javaCode.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/web/javaCode.png" alt="Web Code"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Schema&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Option
@Structure
List&lt;String&gt; config;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/studio/schema.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/studio/schema.png" alt="Studio Schema"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/web/schema.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/web/schema.png" alt="Web Schema"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_validations"&gt;&lt;a class="anchor" href="#_validations"&gt;&lt;/a&gt;1.2. Validations&lt;/h3&gt;
&lt;table class="tableblock frame-all grid-all table gallery"&gt;
&lt;colgroup&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Name&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Code&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Studio Rendering&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Web Rendering&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Property validation&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;/** configuration class */
@Option
@Validable("url")
String config;</p>
</div>
<div class="paragraph">
<p>/<strong> service class <strong>/
@AsyncValidation("url")
ValidationResult doValidate(String url) {
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/studio/prop_validation.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/studio/validation_property.png" alt="Studio Code"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/web/prop_validation.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/web/validation_property.png" alt="Web Code"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Data store validation&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Datastore
@Checkable
public class config {
/</strong> config &#8230;&#8203;</strong>/
}</p>
</div>
<div class="paragraph">
<p>/** service class */
@HealthCheck
public HealthCheckStatus testConnection(){</p>
</div>
<div class="paragraph">
<p>}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/studio/prop_validation.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/studio/validation_datastore.png" alt="Studio Code"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="imageblock"&gt;
&lt;div class="content"&gt;
&lt;a class="image" href="images/gallery/widgets/web/prop_validation.png" target="_blank" rel="noopener"&gt;&lt;img src="_images/gallery/widgets/web/validation_datastore.png" alt="Web Code"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;div id="preamble"&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;As seen in the &lt;a href="getting-started.html#getting-started-first-quick-start" class="page"&gt;Getting Started&lt;/a&gt;, you need an annotation to register
your component through &lt;code&gt;family&lt;/code&gt; method. Multiple components can use the same &lt;code&gt;family&lt;/code&gt; value but the pair &lt;code&gt;family&lt;/code&gt;+&lt;code&gt;name&lt;/code&gt;
&lt;code&gt;MUST&lt;/code&gt; be unique for the system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If you desire (recommended) to share the same component family name instead of repeating yourself in all &lt;code&gt;family&lt;/code&gt; methods,
you can use &lt;code&gt;@Components&lt;/code&gt; annotation on the root package of you component, it will enable you to define the component family and
the categories the component belongs to (default is &lt;code&gt;Misc&lt;/code&gt; if not set). Here is a sample &lt;code&gt;package-info.java&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Components(name = "my_component_family", categories = "My Category")
package org.talend.sdk.component.sample;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;import org.talend.sdk.component.api.component.Components;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For an existing component it can look like:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Components(name = "Salesforce", categories = {"Business", "Cloud"})
package org.talend.sdk.component.sample;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;import org.talend.sdk.component.api.component.Components;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_components_metadata"&gt;&lt;a class="anchor" href="#_components_metadata"&gt;&lt;/a&gt;1. Components metadata&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Components can require a few metadata to be integrated in Talend Studio or Cloud platform. Here is how to provide these information.
These metadata are set on the component class and belongs to &lt;code&gt;org.talend.sdk.component.api.component&lt;/code&gt; package.&lt;/p&gt;
&lt;/div&gt;
&lt;table class="tableblock frame-all grid-all"&gt;
&lt;colgroup&gt;
&lt;col&gt;
&lt;col&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class="tableblock halign-left valign-top"&gt;API&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@Icon&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Set an icon key used to represent the component. Note you can use a custom key with &lt;code&gt;custom()&lt;/code&gt; method but it is not guaranteed the icon will be rendered properly.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@Version&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Set the component version, default to 1.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Icon(FILE_XML_O)
@PartitionMapper(name = "jaxbInput")
public class JaxbPartitionMapper implements Serializable {
    // &#8230;&#8203;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_management_of_configuration_versions"&gt;&lt;a class="anchor" href="#_management_of_configuration_versions"&gt;&lt;/a&gt;1.1. Management of configuration versions&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If some impacting changes happen on the configuration they can be manage through a migration handler at &lt;strong&gt;component&lt;/strong&gt; level (to enable
to support trans-model migration).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The &lt;code&gt;@Version&lt;/code&gt; annotation supports a &lt;code&gt;migrationHandler&lt;/code&gt; method which will take the implementation migrating the incoming configuration
to the current model.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For instance if &lt;code&gt;filepath&lt;/code&gt; configuration entry from v1 changed to &lt;code&gt;location&lt;/code&gt; in v2 you can remap the value to the right key in your
&lt;code&gt;MigrationHandler&lt;/code&gt; implementation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock tip"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-tip" title="Tip"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
it is recommanded to not manage all migrations in the handler but rather split it in services you inject in the migration handler
(through constructor):
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;// full component code structure skipped for brievity, kept only migration part
@Version(value = 3, migrationHandler = MyComponent.Migrations.class)
public class MyComponent {
    // the component code&#8230;&#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="literalblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;private interface VersionConfigurationHandler {
    Map&amp;lt;String, String&amp;gt; migrate(Map&amp;lt;String, String&amp;gt; incomingData);
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="literalblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;public static class Migrations {
    private final List&amp;lt;VersionConfigurationHandler&amp;gt; handlers;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="literalblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;// VersionConfigurationHandler implementations are decorated with @Service
public Migrations(final List&amp;lt;VersionConfigurationHandler&amp;gt; migrations) {
    this.handlers = migrations;
    this.handlers.sort(/<strong>some custom logic</strong>/);
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="literalblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;        @Override
        public Map&amp;lt;String, String&amp;gt; migrate(int incomingVersion, Map&amp;lt;String, String&amp;gt; incomingData) {
            Map&amp;lt;String, String&amp;gt; out = incomingData;
            for (MigrationHandler handler : handlers) {
                out = handler.migrate(out);
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;What is important in this snippet is not much the way the code is organized but rather the fact you organize your migrations the way which fits the best
your component. If migrations are not conflicting no need of something fancy, just apply them all but if you need to apply them in order
you need to ensure they are sorted. Said otherwise: don&amp;#8217;t see this API as a migration API but as a migration callback
and adjust the migration code structure you need behind the &lt;code&gt;MigrationHandler&lt;/code&gt; based on your
component requirements. The service injection enables you to do so.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_partitionmapper"&gt;&lt;a class="anchor" href="#_partitionmapper"&gt;&lt;/a&gt;1.2. @PartitionMapper&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;@PartitionMapper&lt;/code&gt; will obviously mark a partition mapper:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@PartitionMapper(family = "demo", name = "my_mapper")
public class MyMapper {
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_emitter"&gt;&lt;a class="anchor" href="#_emitter"&gt;&lt;/a&gt;1.2.1. @Emitter&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;@Emitter&lt;/code&gt; is a shortcut for &lt;code&gt;@PartitionMapper&lt;/code&gt; when you don&amp;#8217;t support distribution. Said otherwise it will enforce an implicit
partition mapper execution with an assessor size of 1 and a split returning itself.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Emitter(family = "demo", name = "my_input")
public class MyInput {
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_processor"&gt;&lt;a class="anchor" href="#_processor"&gt;&lt;/a&gt;1.3. @Processor&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A method decorated with &lt;code&gt;@Processor&lt;/code&gt; will be considered as a producer factory:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Processor(family = "demo", name = "my_processor")
public class MyProcessor {
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;div id="preamble"&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In the simplest case you should store messages using &lt;code&gt;ResourceBundle&lt;/code&gt; properties file in your component module to use internationalization.
The location of the properties file should be in the same package as the related component(s) and is named &lt;code&gt;Messages&lt;/code&gt; (ex: &lt;code&gt;org.talend.demo.MyComponent&lt;/code&gt; will use &lt;code&gt;org.talend.demo.Messages[locale].properties&lt;/code&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_default_components_keys"&gt;&lt;a class="anchor" href="#_default_components_keys"&gt;&lt;/a&gt;1. Default components keys&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Out of the box components are internationalized using the same location logic for the resource bundle and here is the list
of supported keys:&lt;/p&gt;
&lt;/div&gt;
&lt;table class="tableblock frame-all grid-all"&gt;
&lt;colgroup&gt;
&lt;col&gt;
&lt;col&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Name Pattern&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;${family}._displayName&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;the display name of the family&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;${family}.${configurationType}.${name}._displayName&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;the display name of a configuration type (dataStore or dataSet)&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;${family}.${component_name}._displayName&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;the display name of the component (used by the GUIs)&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;${property_path}._displayName&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;the display name of the option.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;${simple_class_name}.${property_name}._displayName&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;the display name of the option using it class name.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;${property_path}._placeholder&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;the placeholder of the option.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Example of configuration for a component named &lt;code&gt;list&lt;/code&gt; belonging to the family &lt;code&gt;memory&lt;/code&gt; (&lt;code&gt;@Emitter(family = "memory", name = "list")&lt;/code&gt;):&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code&gt;memory.list._displayName = Memory List&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Configuration class are also translatable using the simple class name in the messages properties file.
This useful when you have some common configuration shared within multiple components.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If you have a configuration class like :&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public class MyConfig {&lt;/p&gt;
&lt;/div&gt;
&lt;div class="literalblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;@Option
private String host;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="literalblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;    @Option
    private int port;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;You can give it a translatable display name by adding ${simple_class_name}.${property_name}._displayName to Messages.properties under the same package as the config class.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code&gt;MyConfig.host._displayName = Server Host Name
MyConfig.host._placeholder = Enter Server Host Name&#8230;&#8203;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;MyConfig.port._displayName = Server Port
MyConfig.port._placeholder = Enter Server Port&#8230;&#8203;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
If you have a display name using the property path, it will override the display name defined using the simple class name.
this rule apply also to placeholders
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</p>
</div>
<div class="paragraph">
<p>&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;div id="preamble"&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Talend Component scanning is based on a plugin concept. To ensure plugins can be developped in parallel and avoid conflicts
it requires to isolate plugins (components or component grouped in a single jar/plugin).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here we have multiple options which are (high level):&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;flat classpath: listed for completeness but rejected &lt;em&gt;by design&lt;/em&gt; because it doesn&#8217;t match at all this requirement.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tree classloading: a shared classloader inherited by plugin classloaders but plugin classloader classes
are not seen by the shared classloader nor by other plugins.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;graph classloading: this one allows you to link the plugins and dependencies together dynamically in any direction.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If you want to map it to concrete common examples, the tree classloading is commonly used by Servlet containers where plugins are web applications
and the graph classloading can be illustrated by OSGi containers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In the spirit of avoiding a lot of complexity added by this layer, Talend Component relies on a tree classloading. The advantage
is you don&#8217;t need to define the relationship with other plugins/dependencies (it is built-in).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here is a representation of this solution:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;span class="image"&gt;&lt;img src="_images/classloader-layout.png" alt="classloader layout"&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The interesting part is the &lt;em&gt;shared&lt;/em&gt; area will contain Talend Component API which is the only (by default) shared classes accross the whole plugins.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Then each plugins will be loaded in their own classloader with their dependencies.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_packaging_a_plugin"&gt;&lt;a class="anchor" href="#_packaging_a_plugin"&gt;&lt;/a&gt;1. Packaging a plugin&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="admonitionblock note"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-note" title="Note"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
this part explains the overall way to handle dependecnies but the Talend Maven plugin provides a shortcut for that.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A plugin is just a jar which was enriched with the list of its dependencies. By default Talend Component runtime is able to
read the output of &lt;code&gt;maven-dependency-plugin&lt;/code&gt; in &lt;code&gt;TALEND-INF/dependencies.txt&lt;/code&gt; location so you just need to ensure your component defines the following plugin:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;plugin&gt;
  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
  &lt;version&gt;3.0.2&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;create-TALEND-INF/dependencies.txt&lt;/id&gt;
      &lt;phase&gt;process-resources&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;list&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;outputFile&gt;${project.build.outputDirectory}/TALEND-INF/dependencies.txt&lt;/outputFile&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If you check your jar once built you will see that the file contains something like:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-bash hljs" data-lang="bash"&gt;$ unzip -p target/mycomponent-1.0.0-SNAPSHOT.jar TALEND-INF/dependencies.txt&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The following files have been resolved:
   org.talend.sdk.component:component-api:jar:1.0.0-SNAPSHOT:provided
   org.apache.geronimo.specs:geronimo-annotation_1.3_spec:jar:1.0:provided
   org.superbiz:awesome-project:jar:1.2.3:compile
   junit:junit:jar:4.12:test
   org.hamcrest:hamcrest-core:jar:1.3:test&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;What is important to see is the scope associated to the artifacts:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the API (&lt;code&gt;component-api&lt;/code&gt; and &lt;code&gt;geronimo-annotation_1.3_spec&lt;/code&gt;) are &lt;code&gt;provided&lt;/code&gt; because you can consider them to be there when executing (it comes with the framework)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;your specific dependencies (&lt;code&gt;awesome-project&lt;/code&gt;) is &lt;code&gt;compile&lt;/code&gt;: it will be included as a needed dependency by the framework (note that using &lt;code&gt;runtime&lt;/code&gt; works too).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the other dependencies will be ignored (&lt;code&gt;test&lt;/code&gt; dependencies)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_packaging_an_application"&gt;&lt;a class="anchor" href="#_packaging_an_application"&gt;&lt;/a&gt;2. Packaging an application&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Even if a flat classpath deployment is possible, it is not recommanded because it would then reduce the capabilities of the components.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_dependencies"&gt;&lt;a class="anchor" href="#_dependencies"&gt;&lt;/a&gt;2.1. Dependencies&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The way the framework resolves dependencies is based on a local maven repository layout. As a quick reminder it looks like:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code&gt;.
├── groupId1
│   └── artifactId1
│       ├── version1
│       │   └── artifactId1-version1.jar
│       └── version2
│           └── artifactId1-version2.jar
└── groupId2
    └── artifactId2
        └── version1
            └── artifactId2-version1.jar&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This is all the layout the framework will use. Concretely the logic will convert the t-uple {groupId, artifactId, version, type (jar)}
to the path in the repository.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Talend Component runtime has two ways to find an artifact:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;from the file system based on a configure maven 2 repository.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;from a fatjar (uber jar) with a nested maven repository under &lt;code&gt;MAVEN-INF/repository&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The first option will use either - by default - &lt;code&gt;${user.home}/.m2/repository&lt;/code&gt; or a specific path configured when creating a &lt;code&gt;ComponentManager&lt;/code&gt;.
The nested repository option will need some configuration during the packaging to ensure the repository is well created.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_create_a_nested_maven_repository_with_maven_shade_plugin"&gt;&lt;a class="anchor" href="#_create_a_nested_maven_repository_with_maven_shade_plugin"&gt;&lt;/a&gt;2.1.1. Create a nested maven repository with maven-shade-plugin&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To create the nested &lt;code&gt;MAVEN-INF/repository&lt;/code&gt; repository you can use &lt;code&gt;nested-maven-repository&lt;/code&gt; extension:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;plugin&gt;
  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
  &lt;version&gt;3.0.0&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;phase&gt;package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;shade&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;transformers&gt;
          &lt;transformer implementation="org.talend.sdk.component.container.maven.shade.ContainerDependenciesTransformer"&gt;
            &lt;session&gt;${session}&lt;/project&gt;
          &lt;/transformer&gt;
        &lt;/transformers&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
      &lt;artifactId&gt;nested-maven-repository&lt;/artifactId&gt;
      &lt;version&gt;${the.plugin.version}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_listing_needed_plugins"&gt;&lt;a class="anchor" href="#_listing_needed_plugins"&gt;&lt;/a&gt;2.2. Listing needed plugins&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Plugin are programmatically registered in general but if you want to make some of them automatically available you
need to generate a &lt;code&gt;TALEND-INF/plugins.properties&lt;/code&gt; which will map a plugin name to coordinates found with the maven mecanism
we just talked about.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here again we can enrich &lt;code&gt;maven-shade-plugin&lt;/code&gt; to do it:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;plugin&gt;
  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
  &lt;version&gt;3.0.0&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;phase&gt;package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;shade&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;transformers&gt;
          &lt;transformer implementation="org.talend.sdk.component.container.maven.shade.PluginTransformer"&gt;
            &lt;session&gt;${session}&lt;/project&gt;
          &lt;/transformer&gt;
        &lt;/transformers&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
      &lt;artifactId&gt;nested-maven-repository&lt;/artifactId&gt;
      &lt;version&gt;${the.plugin.version}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_code_maven_shade_plugin_code_extensions"&gt;&lt;a class="anchor" href="#_code_maven_shade_plugin_code_extensions"&gt;&lt;/a&gt;2.3. &lt;code&gt;maven-shade-plugin&lt;/code&gt; extensions&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here is a final job/application bundle based on maven shade plugin:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;plugin&gt;
  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
  &lt;version&gt;3.0.0&lt;/version&gt;
  &lt;configuration&gt;
    &lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt;
    &lt;filters&gt;
      &lt;filter&gt;
        &lt;artifact&gt;*:*&lt;/artifact&gt;
        &lt;excludes&gt;
          &lt;exclude&gt;META-INF/&lt;strong&gt;.SF&lt;/exclude&gt;
          &lt;exclude&gt;META-INF/&lt;/strong&gt;.DSA&lt;/exclude&gt;
          &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;
        &lt;/excludes&gt;
      &lt;/filter&gt;
    &lt;/filters&gt;
  &lt;/configuration&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;phase&gt;package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;shade&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;shadedClassifierName&gt;shaded&lt;/shadedClassifierName&gt;
        &lt;transformers&gt;
          &lt;transformer
              implementation="org.talend.sdk.component.container.maven.shade.ContainerDependenciesTransformer"&gt;
            &lt;session&gt;${session}&lt;/session&gt;
            &lt;userArtifacts&gt;
              &lt;artifact&gt;
                &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
                &lt;artifactId&gt;sample-component&lt;/artifactId&gt;
                &lt;version&gt;1.0&lt;/version&gt;
                &lt;type&gt;jar&lt;/type&gt;
              &lt;/artifact&gt;
            &lt;/userArtifacts&gt;
          &lt;/transformer&gt;
          &lt;transformer implementation="org.talend.sdk.component.container.maven.shade.PluginTransformer"&gt;
            &lt;session&gt;${session}&lt;/session&gt;
            &lt;userArtifacts&gt;
              &lt;artifact&gt;
                &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
                &lt;artifactId&gt;sample-component&lt;/artifactId&gt;
                &lt;version&gt;1.0&lt;/version&gt;
                &lt;type&gt;jar&lt;/type&gt;
              &lt;/artifact&gt;
            &lt;/userArtifacts&gt;
          &lt;/transformer&gt;
        &lt;/transformers&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
      &lt;artifactId&gt;nested-maven-repository-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;${the.version}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="admonitionblock note"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-note" title="Note"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
the configuration unrelated to transformers can depend your application.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;ContainerDependenciesTransformer&lt;/code&gt; is the one to embed a maven repository and &lt;code&gt;PluginTransformer&lt;/code&gt; to create a file listing (one per line)
a list of artifacts (representing plugins).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Both transformers share most of their configuration:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;session&lt;/code&gt;: must be set to &lt;code&gt;${session}&lt;/code&gt;. This is used to retrieve dependencies.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;scope&lt;/code&gt;: a comma separated list of scope to include in the artifact filtering (note that the default will rely on &lt;code&gt;provided&lt;/code&gt; but you can replace it by &lt;code&gt;compile&lt;/code&gt;, &lt;code&gt;runtime&lt;/code&gt;, &lt;code&gt;runtime+compile&lt;/code&gt;, &lt;code&gt;runtime+system&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;include&lt;/code&gt;: a comma separated list of artifact to include in the artifact filtering.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;exclude&lt;/code&gt;: a comma separated list of artifact to exclude in the artifact filtering.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;userArtifacts&lt;/code&gt;: a list of artifacts (groupId, artifactId, version, type - optional, file - optional for plugin transformer, scope - optional) which can be forced inline - mainly useful for &lt;code&gt;PluginTransformer&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;includeTransitiveDependencies&lt;/code&gt;: should transitive dependencies of the components be included, true by default.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;includeProjectComponentDependencies&lt;/code&gt;: should project component dependencies be included, false by default (normally a job project uses isolation for components so this is not needed).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;userArtifacts&lt;/code&gt;: set of component artifacts to include.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
to use with the component tooling, it is recommended to keep default locations. Also if you feel you need to use project dependencies,
you can need to refactor your project structure to ensure you keep component isolation. Talend component let you handle that part but the recommended
practise is to use &lt;code&gt;userArtifacts&lt;/code&gt; for the components and not the project &lt;code&gt;&lt;dependencies&gt;&lt;/code&gt;.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_containerdependenciestransformer"&gt;&lt;a class="anchor" href="#_containerdependenciestransformer"&gt;&lt;/a&gt;2.3.1. ContainerDependenciesTransformer&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;ContainerDependenciesTransformer&lt;/code&gt; specific configuration is the following one:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;repositoryBase&lt;/code&gt;: base repository location (default to &lt;code&gt;MAVEN-INF/repository&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ignoredPaths&lt;/code&gt;: a comma separated list of folder to not create in the output jar, this is common for the ones already created by other transformers/build parts.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_plugintransformer"&gt;&lt;a class="anchor" href="#_plugintransformer"&gt;&lt;/a&gt;2.3.2. PluginTransformer&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;ContainerDependenciesTransformer&lt;/code&gt; specific configuration is the following one:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;pluginListResource&lt;/code&gt;: base repository location (default to TALEND-INF/plugins.properties`).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Example: if you want to list only the plugins you use you can configure this transformer like that:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;transformer implementation="org.talend.sdk.component.container.maven.shade.PluginTransformer"&gt;
  &lt;session&gt;${session}&lt;/session&gt;
  &lt;include&gt;org.talend.sdk.component:component-x,org.talend.sdk.component:component-y,org.talend.sdk.component:component-z&lt;/include&gt;
&lt;/transformer&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;</p>
</div>
<div class="paragraph">
<p>&lt;div id="preamble"&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;div id="preamble"&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;talend-component-maven-plugin&lt;/code&gt; intends to help you to write components
validating components match best practices and also generating transparently metadata used by Talend Studio.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here is how to use it:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;plugin&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${component.version}&lt;/version&gt;
&lt;/plugin&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Note that this plugin is also an extension so you can declare it in your &lt;code&gt;build/extensions&lt;/code&gt; block as:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;extension&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${component.version}&lt;/version&gt;
&lt;/extension&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Used as an extension, &lt;code&gt;dependencies&lt;/code&gt;, &lt;code&gt;validate&lt;/code&gt; and &lt;code&gt;documentation&lt;/code&gt; goals will be set up.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_dependencies"&gt;&lt;a class="anchor" href="&lt;mark&gt;_dependencies"&gt;&lt;/a&gt;1. Dependencies&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The first goal is a shortcut for the &lt;code&gt;maven-dependency-plugin&lt;/code&gt;, it will create the &lt;code&gt;TALEND-INF/dependencies.txt&lt;/code&gt; file
with the &lt;code&gt;compile&lt;/code&gt; and &lt;code&gt;runtime&lt;/code&gt; dependencies to let the component use it at runtime:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;plugin&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${component.version}&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;talend-dependencies&lt;/id&gt;
      &lt;goals&gt;
        &lt;goal&gt;dependencies&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_validate"&gt;&lt;a class="anchor" href="#_validate"&gt;&lt;/a&gt;2. Validate&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The most important goal is here to help you to validate the common programming model of the component. Here is the execution definition to activate it:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;plugin&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${component.version}&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;talend-component-validate&lt;/id&gt;
      &lt;goals&gt;
        &lt;goal&gt;validate&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;By default it will be bound to &lt;code&gt;process-classes&lt;/code&gt; phase. When executing it will do several validations which can be switched off
adding the corresponding flags to &lt;code&gt;false&lt;/code&gt; in the &lt;code&gt;&lt;configuration&gt;&lt;/code&gt; block of the execution:&lt;/p&gt;
&lt;/div&gt;
&lt;table class="tableblock frame-all grid-all"&gt;
&lt;colgroup&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Name&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Description&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Default&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;validateInternationalization&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Validates resource bundle are presents and contain commonly used keys (like &lt;code&gt;_displayName&lt;/code&gt;)&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;true&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;validateModel&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Ensure components pass validations of the &lt;code&gt;ComponentManager&lt;/code&gt; and Talend Component runtime&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;true&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;validateSerializable&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Ensure components are &lt;code&gt;Serializable&lt;/code&gt; - note this is a sanity check, the component is not actually serialized here, if you have a doubt ensure to test it. It also checks any &lt;code&gt;@Internationalized&lt;/code&gt; class is valid and has its keys.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;true&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;validateMetadata&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Ensure components define an &lt;code&gt;@Icon&lt;/code&gt; and &lt;code&gt;@Version&lt;/code&gt;.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;true&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;validateDataStore&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Ensure any  &lt;code&gt;@DataStore&lt;/code&gt; defines a &lt;code&gt;@HealthCheck&lt;/code&gt;.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;true&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;validateComponent&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Ensure native programming model is respected, you can disable it when using another programming model like in beam case.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;true&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;validateActions&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Validate actions signatures for the ones not tolerating dynamic binding (&lt;code&gt;@HealthCheck&lt;/code&gt;, &lt;code&gt;@DynamicValues&lt;/code&gt;, &#8230;&#8203;). It is recommanded to keep it &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;true&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;validateFamily&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Validate the family, i.e. the package containing the &lt;code&gt;@Components&lt;/code&gt; has also a &lt;code&gt;@Icon&lt;/code&gt;.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;true&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;validateDocumentation&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Ensure all 1. components and 2. &lt;code&gt;@Option&lt;/code&gt; properties have a documentation using &lt;code&gt;@Documentation&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;true&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_documentation"&gt;&lt;a class="anchor" href="#_documentation"&gt;&lt;/a&gt;3. Documentation&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This goal generates an Asciidoc file documenting your component from the configuration model (&lt;code&gt;@Option&lt;/code&gt;) and
&lt;code&gt;@Documentation&lt;/code&gt; you can put on options and the component itself.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;plugin&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${component.version}&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;talend-component-documentation&lt;/id&gt;
      &lt;goals&gt;
        &lt;goal&gt;asciidoc&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;table class="tableblock frame-all grid-all"&gt;
&lt;colgroup&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Name&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Description&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Default&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;level&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Which level are the root title&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;2 which means &lt;code&gt;==&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;output&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;Where to store the output, it is &lt;strong&gt;NOT&lt;/strong&gt; recommended to change it&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;${classes}/TALEND-INF/documentation.adoc&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;formats&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;A map of the renderings to do, keys are the format (&lt;code&gt;pdf&lt;/code&gt; or &lt;code&gt;html&lt;/code&gt;) and values the output paths&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;attributes&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;A map of asciidoctor attributes when formats is set&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;templateDir / templateEngine&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Template configuration for the rendering&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;title&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Document title&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;${project.name}&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;attachDocumentations&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Should the documentations (&lt;code&gt;.adoc&lt;/code&gt;, and &lt;code&gt;formats&lt;/code&gt; keys) should be attached to the project (and deployed)&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;true&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="admonitionblock tip"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-tip" title="Tip"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
if you use the extension you can add the property &lt;code&gt;talend.documentation.htmlAndPdf&lt;/code&gt; and set it to &lt;code&gt;true&lt;/code&gt; in your project
to automatically get a html and PDF rendering of the documentation.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_render_your_documentation"&gt;&lt;a class="anchor" href="#_render_your_documentation"&gt;&lt;/a&gt;3.1. Render your documentation&lt;/h3&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_html"&gt;&lt;a class="anchor" href="#_html"&gt;&lt;/a&gt;3.1.1. HTML&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To render the generated documentation you can use the Asciidoctor Maven plugin (or Gradle equivalent):&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;plugin&gt; (1)
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${talend-component-kit.version}&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;documentation&lt;/id&gt;
      &lt;phase&gt;prepare-package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;asciidoc&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;
&lt;plugin&gt; (2)
  &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;
  &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.5.6&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;doc-html&lt;/id&gt;
      &lt;phase&gt;prepare-package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;process-asciidoc&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;sourceDirectory&gt;${project.build.outputDirectory}/TALEND-INF&lt;/sourceDirectory&gt;
        &lt;sourceDocumentName&gt;documentation.adoc&lt;/sourceDocumentName&gt;
        &lt;outputDirectory&gt;${project.build.directory}/documentation&lt;/outputDirectory&gt;
        &lt;backend&gt;html5&lt;/backend&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="olist arabic"&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;
&lt;p&gt;Will generate in &lt;code&gt;target/classes/TALEND-INF/documentation.adoc&lt;/code&gt; the components documentation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Will render the documenation as an html file in &lt;code&gt;target/documentation/documentation.html&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="admonitionblock tip"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-tip" title="Tip"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
ensure to execute it after the documentation generation.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_pdf"&gt;&lt;a class="anchor" href="#_pdf"&gt;&lt;/a&gt;3.1.2. PDF&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If you prefer a PDF rendering you can configure the following execution
in the asciidoctor plugin (note that you can configure both executions if you want
both HTML and PDF rendering):&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;plugin&gt;
  &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;
  &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.5.6&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;doc-html&lt;/id&gt;
      &lt;phase&gt;prepare-package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;process-asciidoc&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;sourceDirectory&gt;${project.build.outputDirectory}/TALEND-INF&lt;/sourceDirectory&gt;
        &lt;sourceDocumentName&gt;documentation.adoc&lt;/sourceDocumentName&gt;
        &lt;outputDirectory&gt;${project.build.directory}/documentation&lt;/outputDirectory&gt;
        &lt;backend&gt;pdf&lt;/backend&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;
      &lt;artifactId&gt;asciidoctorj-pdf&lt;/artifactId&gt;
      &lt;version&gt;1.5.0-alpha.16&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_include_the_documentation_into_a_document"&gt;&lt;a class="anchor" href="#_include_the_documentation_into_a_document"&gt;&lt;/a&gt;3.1.3. Include the documentation into a document&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If you want to add some more content or add a title, you can include the generated document into
another document using Asciidoc &lt;code&gt;include&lt;/code&gt; directive.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A common example is:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-adoc hljs" data-lang="adoc"&gt;= Super Components
Super Writer
:toc:
:toclevels: 3
:source-highlighter: prettify
:numbered:
:icons: font
:hide-uri-scheme:
:imagesdir: images&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This assumes you pass to the plugin the attribute &lt;code&gt;generated_doc&lt;/code&gt;, this can be done this way:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;plugin&gt;
  &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;
  &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.5.6&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;doc-html&lt;/id&gt;
      &lt;phase&gt;prepare-package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;process-asciidoc&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;sourceDirectory&gt;${project.basedir}/src/main/asciidoc&lt;/sourceDirectory&gt;
        &lt;sourceDocumentName&gt;my-main-doc.adoc&lt;/sourceDocumentName&gt;
        &lt;outputDirectory&gt;${project.build.directory}/documentation&lt;/outputDirectory&gt;
        &lt;backend&gt;html5&lt;/backend&gt;
        &lt;attributes&gt;
          &lt;generated_adoc&gt;${project.build.outputDirectory}/TALEND-INF&lt;/generated_adoc&gt;
        &lt;/attributes&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This is optional but allows to reuse maven placeholders to pass paths which is quite convenient in an automated build.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_more"&gt;&lt;a class="anchor" href="#_more"&gt;&lt;/a&gt;3.1.4. More&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;You can find more customizations on Asciidoctor &lt;a href="http://asciidoctor.org/docs/asciidoctor-maven-plugin/"&gt;website&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_web"&gt;&lt;a class="anchor" href="#_web"&gt;&lt;/a&gt;4. Web&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Testing the rendering of your component(s) configuration into the Studio is just a matter of deploying a component
in Talend Studio (you can have a look to link::studio.html[Studio Documentation] page. But don&#8217;t forget
the component can also be deployed into a Cloud (web) environment. To ease the testing of the related rendering,
you can use the goal &lt;code&gt;web&lt;/code&gt; of the plugin:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code&gt;mvn talend-component:web&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Then you can test your component going on &lt;a href="http://localhost:8080" class="bare"&gt;localhost:8080&lt;/a&gt;. You need to select which component form you want
to see using the treeview on the left, then on the right the form will be displayed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The two available configurations of the plugin are &lt;code&gt;serverPort&lt;/code&gt; which is a shortcut to change the default, 8080, port
of the embedded server and &lt;code&gt;serverArguments&lt;/code&gt; to pass Meecrowave options to the server. More on that configuration
is available at &lt;a href="http://openwebbeans.apache.org/meecrowave/meecrowave-core/cli.html" class="bare"&gt;openwebbeans.apache.org/meecrowave/meecrowave-core/cli.html&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
this command reads the component jar from the local maven repository so ensure to install the artifact before using it.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_generate_inputs_or_outputs"&gt;&lt;a class="anchor" href="#_generate_inputs_or_outputs"&gt;&lt;/a&gt;5. Generate inputs or outputs&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The Mojo &lt;code&gt;generate&lt;/code&gt; (maven plugin goal) of the same plugin also embeds a generator you can use to bootstrap any input or output component:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;plugin&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${talend-component.version}&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt; &lt;i class="conum" data-value="1"&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
      &lt;id&gt;generate-input&lt;/id&gt;
      &lt;phase&gt;generate-sources&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;generate&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;type&gt;input&lt;/type&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
    &lt;execution&gt; &lt;i class="conum" data-value="2"&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
      &lt;id&gt;generate-output&lt;/id&gt;
      &lt;phase&gt;generate-sources&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;generate&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;type&gt;output&lt;/type&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="colist arabic"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="1"&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;Generates an input (partition mapper + emitter)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="2"&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;Generates an output&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is intended to be used from the command line (or IDE Maven integration):&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-sh hljs" data-lang="sh"&gt;$ mvn talend-component:generate \
    -Dtalend.generator.type=[input|output] \ &lt;i class="conum" data-value="1"&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    [-Dtalend.generator.classbase=com.test.MyComponent] \ &lt;i class="conum" data-value="2"&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
    [-Dtalend.generator.family=my-family] \ &lt;i class="conum" data-value="3"&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
    [-Dtalend.generator.pom.read-only=false] &lt;i class="conum" data-value="4"&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="colist arabic"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="1"&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;select the type of component you want, &lt;code&gt;input&lt;/code&gt; to generate a mapper and emitter and &lt;code&gt;output&lt;/code&gt; to generate an output processor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="2"&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;set the class name base (will be suffixed by the component type), if not set the package will be guessed and classname based on the basedir name&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="3"&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;set the component family to use, default to the base dir name removing (component[s] from the name, ex: &lt;code&gt;my-component&lt;/code&gt; will lead to &lt;code&gt;my&lt;/code&gt; as family if not explicitly set)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="4"&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;should the generator try to add &lt;code&gt;component-api&lt;/code&gt; in the pom if not already here, if you added it you can set it to &lt;code&gt;false&lt;/code&gt; directly in the pom&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For this command to work you will need to just register the plugin:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;plugin&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${talend-component.version}&lt;/version&gt;
&lt;/plugin&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_talend_component_archive"&gt;&lt;a class="anchor" href="#_talend_component_archive"&gt;&lt;/a&gt;6. Talend Component Archive&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Component ARchive (&lt;code&gt;.car&lt;/code&gt;) is the way to bundle a component to share it in Talend ecosystem. It is a plain Java ARchive (&lt;code&gt;.jar&lt;/code&gt;)
containing a metadata file and a nested maven repository containing the component and its depenencies.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code&gt;mvn talend-component:car&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It will create a &lt;code&gt;.car&lt;/code&gt; in your build directory which is shareable on Talend platforms.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Note that this CAR is executable and exposes the command &lt;code&gt;studio-deploy&lt;/code&gt; which takes as parameter
a Talend Studio home location. Executed it will install the dependencies into the studio and register the component
in your instance. Here is a sample launch command:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-sh hljs" data-lang="sh"&gt;&lt;/mark&gt; for a studio
java -jar mycomponent.car studio-deploy /path/to/my/studio&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_for_a_m2_provisioning"&gt;&lt;a class="anchor" href="#_for_a_m2_provisioning"&gt;&lt;/a&gt;1. for a m2 provisioning&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;java -jar mycomponent.car maven-deploy /path/to/.m2/repository&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;gradle-talend-component&lt;/code&gt; intends to help you to write components
validating components match best practices. It is inspired from the Maven plugin
and adds the ability to generate automatically the &lt;code&gt;dependencies.txt&lt;/code&gt; file the SDK
uses to build the component classpath. For more information on the configuration
you can check out the maven properties matching the attributes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here is how to use it:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-groovy hljs" data-lang="groovy"&gt;buildscript {
  repositories {
    mavenLocal()
    mavenCentral()
  }
  dependencies {
    classpath "org.talend.sdk.component:gradle-talend-component:${talendComponentVersion}"
  }
}&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;apply plugin: 'org.talend.sdk.component'
apply plugin: 'java'&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;talendComponentKit {
    // dependencies.txt generation, replaces maven-dependency-plugin
    dependenciesLocation = "TALEND-INF/dependencies.txt"
    boolean skipDependenciesFile = false;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="literalblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;// classpath for validation utilities
sdkVersion = "${talendComponentVersion}"
apiVersion = "${talendComponentApiVersion}"&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="literalblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;// documentation
skipDocumentation = false
documentationOutput = new File(&#8230;&#8203;.)
documentationLevel = 2 // first level will be == in the generated adoc
documentationTitle = 'My Component Family' // default to project name
documentationFormats = [:] // adoc attributes
documentationFormats = [:] // renderings to do&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="literalblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;// validation
skipValidation = false
validateFamily = true
validateSerializable = true
validateInternationalization = true
validateModel = true
validateMetadata = true
validateComponent = true
validateDataStore = true
validateDataSet = true
validateActions = true&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="literalblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;// web
serverArguments = []
serverPort = 8080&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="literalblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;    // car
    carOutput = new File(&#8230;&#8203;.)
    carMetadata = [:] // custom meta (string key-value pairs)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</p>
</div>
<div class="paragraph">
<p>&lt;div class="sect1"&gt;
&lt;h2 id="_internationalization"&gt;&lt;a class="anchor" href="#_internationalization"&gt;&lt;/a&gt;1. Internationalization&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Recommanded practise for internationalization are:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;store messages using &lt;code&gt;ResourceBundle&lt;/code&gt; properties file in your component module&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the location of the properties are in the same package than the related component(s) and is named &lt;code&gt;Messages&lt;/code&gt; (ex: &lt;code&gt;org.talend.demo.MyComponent&lt;/code&gt; will use &lt;code&gt;org.talend.demo.Messages[locale].properties&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;for your own messages use the internationalization API&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_internationalization_api"&gt;&lt;a class="anchor" href="#_internationalization_api"&gt;&lt;/a&gt;1.1. Internationalization API&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Overal idea is to design its messages as methods returning &lt;code&gt;String&lt;/code&gt; values
and back the template by a &lt;code&gt;ResourceBundle&lt;/code&gt; located in the same package than the interface
defining these methods and named &lt;code&gt;Messages&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
this is the mecanism to use to internationalize your own messages in your own components.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To ensure you internationalization API is identified you need to mark it with &lt;code&gt;@Internationalized&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Internationalized &lt;i class="conum" data-value="1"&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
public interface Translator {</p>
</div>
<div class="literalblock">
<div class="content">
<pre>String message();</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>String templatizedMessage(String arg0, int arg1); &lt;i class="conum" data-value="2"&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    String localized(String arg0, @Language Locale locale); &lt;i class="conum" data-value="3"&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="colist arabic"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="1"&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@Internationalized&lt;/code&gt; allows to mark a class as a i18n service&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="2"&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;you can pass parameters and the message will use &lt;code&gt;MessageFormat&lt;/code&gt; syntax to be resolved based on the &lt;code&gt;ResourceBundle&lt;/code&gt; template&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="3"&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;you can use &lt;code&gt;@Language&lt;/code&gt; on a &lt;code&gt;Locale&lt;/code&gt; parameter to specify manually the locale to use, note that a single value will be used (the first parameter tagged as such).&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_providing_some_actions_for_consumers_clients"&gt;&lt;a class="anchor" href="#_providing_some_actions_for_consumers_clients"&gt;&lt;/a&gt;2. Providing some actions for consumers/clients&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In some cases you will desire to add some actions unrelated to the runtime. A simple example
is to enable clients - the users of the plugin/library - to test if a connection works. Even more concretely: &lt;em&gt;does my database is up?&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To do so you need to define an &lt;code&gt;@Action&lt;/code&gt; which is a method with a name (representing the event name) in a class decorated with &lt;code&gt;@Service&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Service
public class MyDbTester {
    @Action(family = "mycomp", "test")
    public Status doTest(final IncomingData data) {
        return ...;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
services are singleton so if you need some thread safety ensure they match that requirement. They
shouldn&amp;#8217;t store any state too (state is held by the component) since they can be serialized any time.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="admonitionblock tip"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-tip" title="Tip"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
services are usable in components as well (matched by type) and allow to reuse some shared logic like a client. Here is a sample
with a service used to access files:
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Emitter(family = "sample", name = "reader")
public class PersonReader implements Serializable {
    // attributes skipped to be concise</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>public PersonReader(@Option("file") final File file,
                    final FileService service) {
    this.file = file;
    this.service = service;
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>// use the service
@PostConstruct
public void open() throws FileNotFoundException {
    reader = service.createInput(file);
}</pre>
</div>
</div>
<div class="paragraph">
<p>}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="admonitionblock tip"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-tip" title="Tip"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
service is passed to constructor automatically, it can be used as a bean. Only call of service&#8217;s method is required.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_particular_action_types"&gt;&lt;a class="anchor" href="#_particular_action_types"&gt;&lt;/a&gt;2.1. Particular action types&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Some actions are that common and need a clear contract so they are defined as API first citizen, this is the case for wizards or healthchecks
for instance. Here is the list of all actions:&lt;/p&gt;
&lt;/div&gt;
&lt;table class="tableblock frame-all grid-all table-striped table-hover table-ordered"&gt;
&lt;colgroup&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class="tableblock halign-left valign-top"&gt;API&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Type&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Description&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Return type&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Sample returned type&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.service.completion.DynamicValues&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;dynamic_values&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Mark a method as being useful to fill potential values of a string option for a property denoted by its value. You can link a field as being completable using @Proposable(value). The resolution of the completion action is then done through the component family and value of the action. The callback doesn&#8217;t take any parameter.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Values&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;&lt;code&gt;{"items":[{"id":"value","label":"label"}]}&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.service.healthcheck.HealthCheck&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;healthcheck&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;This class marks an action doing a connection test&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;HealthCheckStatus&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;&lt;code&gt;{"comment":"Something went wrong","status":"KO"}&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.service.schema.DiscoverSchema&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;schema&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Mark an action as returning a discovered schema. Its parameter MUST be the type decorated with &lt;code&gt;@Discoverable&lt;/code&gt;.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Schema&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;&lt;code&gt;{"entries":[{"name":"column1","type":"STRING"}]}&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.service.Action&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;user&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;any&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;@org.talend.sdk.component.api.service.asyncvalidation.AsyncValidation&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;validation&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Mark a method as being used to validate a configuration. IMPORTANT: this is a server validation so only use it if you can&#8217;t use other client side validation to implement it.&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;ValidationResult&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;&lt;code&gt;{"comment":"Something went wrong","status":"KO"}&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_built_in_services"&gt;&lt;a class="anchor" href="#_built_in_services"&gt;&lt;/a&gt;3. Built in services&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The framework provides some built-in services you can inject by type in components and actions out of the box.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here is the list:&lt;/p&gt;
&lt;/div&gt;
&lt;table class="tableblock frame-all grid-all"&gt;
&lt;colgroup&gt;
&lt;col&gt;
&lt;col&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Type&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;org.talend.sdk.component.api.service.cache.LocalCache&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Provides a small abstraction to cache data which don&#8217;t need to be recomputed very often. Commonly used by actions for the UI interactions.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;org.talend.sdk.component.api.service.dependency.Resolver&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;Allows to resolve a dependency from its Maven coordinates.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;javax.json.spi.JsonProvider&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;A JSON-P instance. Prefer other JSON-P instances if you don&#8217;t exactly know why you use this one.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;javax.json.JsonBuilderFactory&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;javax.json.JsonWriterFactory&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;javax.json.JsonReaderFactory&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;javax.json.stream.JsonParserFactory&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;javax.json.stream.JsonGeneratorFactory&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
it assumes the dependency is locally available to the execution instance which is not guaranteed yet by the framework.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;org.talend.sdk.component.api.service.configuration.LocalConfiguration&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;Represents the local configuration which can be used during the design.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock warning"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-warning" title="Warning"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
it is not recommanded to use it for the runtime since the local configuration is generally different and the instances are distincts.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="admonitionblock tip"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-tip" title="Tip"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
you can also use the local cache as an interceptor with &lt;code&gt;@Cached&lt;/code&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;Every interface that extends &lt;code&gt;HttpClient&lt;/code&gt; and that contains methods annotated with &lt;code&gt;@Request&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;div&gt;&lt;div class="paragraph"&gt;
&lt;p&gt;This let you define an http client in a declarative manner using an annotated interface.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock tip"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-tip" title="Tip"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
See the &lt;a href="#_httpclient_usage"&gt;HttpClient usage&lt;/a&gt; for details.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_httpclient_usage"&gt;&lt;a class="anchor" href="#_httpclient_usage"&gt;&lt;/a&gt;3.1. HttpClient usage&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Let assume that we have a REST API defined like below, and that it requires a basic authentication header.&lt;/p&gt;
&lt;/div&gt;
&lt;table class="tableblock frame-all grid-all spread"&gt;
&lt;colgroup&gt;
&lt;col style="width: 50%;"&gt;
&lt;col style="width: 50%;"&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;GET     &lt;code&gt;/api/records/{id}&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;POST    &lt;code&gt;/api/records&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;with a json playload to be created &lt;code&gt;{"id":"some id", "data":"some data"}&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To create an http client able to consume this REST API, we will define an interface that extends &lt;code&gt;HttpClient&lt;/code&gt;,&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The &lt;code&gt;HttpClient&lt;/code&gt; interface lets you set the &lt;code&gt;base&lt;/code&gt; for the http address that our client will hit.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The &lt;code&gt;base&lt;/code&gt; is the part of the address that we will need to add to the request path to hit the api.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Every method annotated with &lt;code&gt;@Request&lt;/code&gt; of our interface will define an http request.
Also every request can have &lt;code&gt;@Codec&lt;/code&gt; that let us encode/decode the request/response playloads.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock tip"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-tip" title="Tip"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
if your payload(s) is(are) &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;Void&lt;/code&gt; you can ignore the coder/decoder.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public interface APIClient extends HttpClient {
    @Request(path = "api/records/{id}", method = "GET")
    @Codec(decoder = RecordDecoder.class) //decoder =  decode returned data to Record class
    Record getRecord(@Header("Authorization") String basicAuth, @Path("id") int id);</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    @Request(path = "api/records", method = "POST")
    @Codec(encoder = RecordEncoder.class, decoder = RecordDecoder.class) //encoder = encode record to fit request format (json in this example)
    Record createRecord(@Header("Authorization") String basicAuth, Record record);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
The interface should extends &lt;code&gt;HttpClient&lt;/code&gt;.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In the codec classes (class that implement Encoder/Decoder) you can inject any of your services annotated with &lt;code&gt;@Service&lt;/code&gt; or &lt;code&gt;@Internationalized&lt;/code&gt; into the constructor.
The i18n services can be useful to have i18n messages for errors handling for example.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This interface can be injected into our Components classes or Services to consume the defined api.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Service
public class MyService {</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>private APIClient client;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>public MyService(...,APIClient client){
    //...
    this.client = client;
    client.base("http://localhost:8080");// init the base of the api, ofen in a PostConstruct or init method
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>//...
// Our get request
Record rec =  client.getRecord("Basic MLFKG?VKFJ", 100);</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    //...
    // Our post request
    Record newRecord = client.createRecord("Basic MLFKG?VKFJ", new Record());
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Note: by default &lt;code&gt;&lt;strong&gt;/&lt;/strong&gt;+json&lt;/code&gt; are mapped to JSON-P and &lt;code&gt;&lt;strong&gt;/&lt;/strong&gt;+xml&lt;/code&gt; to JAX-B if the model has a &lt;code&gt;@XmlRootElement&lt;/code&gt; annotation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_advanced_http_client_request_customization"&gt;&lt;a class="anchor" href="#_advanced_http_client_request_customization"&gt;&lt;/a&gt;3.1.1. Advanced HTTP client request customization&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For advanced cases you can customize the &lt;code&gt;Connection&lt;/code&gt; directly using &lt;code&gt;@UseConfigurer&lt;/code&gt; on the method.
It will call your custom instance of &lt;code&gt;Configurer&lt;/code&gt;. Note that you can use some &lt;code&gt;@ConfigurerOption&lt;/code&gt; in the method
signature to pass some configurer configuration.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For instance if you have this configurer:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public class BasicConfigurer implements Configurer {
    @Override
    public void configure(final Connection connection, final ConfigurerConfiguration configuration) {
        final String user = configuration.get("username", String.class);
        final String pwd = configuration.get("password", String.class);
        connection.withHeader(
            "Authorization",
            Base64.getEncoder().encodeToString((user + ':' + pwd).getBytes(StandardCharsets.UTF_8)));
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;You can then set it on a method to automatically add the basic header with this kind of API usage:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public interface APIClient extends HttpClient {
    @Request(path = "...")
    @UseConfigurer(BasicConfigurer.class)
    Record findRecord(@ConfigurerOption("username") String user, @ConfigurerOption("password") String pwd);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_services_and_interceptors"&gt;&lt;a class="anchor" href="#_services_and_interceptors"&gt;&lt;/a&gt;4. Services and interceptors&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For common concerns like caching, auditing etc, it can be fancy to use interceptor like API. It is enabled by the framework
on services.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;An interceptor defines an annotation marked with &lt;code&gt;@Intercepts&lt;/code&gt; which defines the implementation of the interceptor (an &lt;code&gt;InterceptorHandler&lt;/code&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Intercepts(LoggingHandler.class)
@Target({ TYPE, METHOD })
@Retention(RUNTIME)
public @interface Logged {
    String value();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Then handler is created from its constructor and can take service injections (by type). The first parameter, however, can be
a &lt;code&gt;BiFunction&amp;lt;Method, Object[], Object&amp;gt;&lt;/code&gt; which representes the invocation chain if your interceptor can be used with others.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
if you do a generic interceptor it is important to pass the invoker as first parameter. If you don&amp;#8217;t do so
you can&amp;#8217;t combine interceptors at all.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here is an interceptor implementation for our &lt;code&gt;@Logged&lt;/code&gt; API:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public class LoggingHandler implements InterceptorHandler {
    // injected
    private final BiFunction&amp;lt;Method, Object[], Object&amp;gt; invoker;
    private final SomeService service;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>// internal
private final ConcurrentMap&amp;lt;Method, String&amp;gt; loggerNames = new ConcurrentHashMap&amp;lt;&amp;gt;();</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>public CacheHandler(final BiFunction&amp;lt;Method, Object[], Object&amp;gt; invoker, final SomeService service) {
    this.invoker = invoker;
    this.service = service;
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    @Override
    public Object invoke(final Method method, final Object[] args) {
        final String name = loggerNames.computeIfAbsent(method, m -&amp;gt; findAnnotation(m, Logged.class).get().value());
        service.getLogger(name).info("Invoking {}", method.getName());
        return invoker.apply(method, args);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This implementation is compatible with interceptor chains since it takes the invoker as first constructor parameter
and it also takes a service injection. Then the implementation just does what is needed - logging the invoked method here.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock note"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-note" title="Note"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
the &lt;code&gt;findAnnotation&lt;/code&gt; annotation - inherited from &lt;code&gt;InterceptorHandler&lt;/code&gt; is an utility method to find an annotation on a method
or class (in this order).
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_creating_a_job_pipeline"&gt;&lt;a class="anchor" href="#_creating_a_job_pipeline"&gt;&lt;/a&gt;5. Creating a job pipeline&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_job_builder"&gt;&lt;a class="anchor" href="#_job_builder"&gt;&lt;/a&gt;5.1. Job Builder&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The &lt;code&gt;Job&lt;/code&gt; builder let you create a job pipeline programmatically using Talend components
(&lt;a href="latest/component-definition.html"&gt;Producers and Processors&lt;/a&gt;).
The job pipeline is an acyclic graph, so you can built complex pipelines.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Let&amp;#8217;s take a simple use case where we will have 2 data source (employee and salary) that we will format to csv and write
the result to a file.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;Job.components()   &lt;i class="conum" data-value="1"&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
        .component("employee","db://input")
        .component("salary", "db://input")
        .component("concat", "transform://concat?separator=;")
        .component("csv", "file://out?__version=2")
    .connections()  &lt;i class="conum" data-value="2"&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
        .from("employee").to("concat", "string1")
        .from("salary").to("concat", "string2")
        .from("concat").to("csv")
    .build()    &lt;i class="conum" data-value="3"&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
    .run(); &lt;i class="conum" data-value="4"&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Step by step explanation :&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;(1) We define all the components that will be used in the job pipeline.
Every component is defined by an unique &lt;code&gt;id&lt;/code&gt; and an URI that identify the component.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The URI follow the form : &lt;code&gt;[family]://[component][?version][&amp;amp;configuration]&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;family&lt;/strong&gt;: the name of the component family&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;component&lt;/strong&gt;: the name of the component&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;version&lt;/strong&gt; : the version of the component, it&amp;#8217;s represented in a key=value format. where the key is &lt;code&gt;__version&lt;/code&gt; and the value is a number.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;configuration&lt;/strong&gt;: here you can provide the component configuration as key=value tuple.
where the key is the path of the configuration and the value is the configuration value in string format.&lt;/p&gt;
&lt;div class="literalblock"&gt;
&lt;div class="content"&gt;
&lt;pre&gt;EXAMPLE: "job://csvFileGen?__version=1&amp;amp;path=/temp/result.csv&amp;amp;encoding=utf-8"&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
configuration parameters must be URI/URL encoded.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;(2) Then, we define the connections between the components to construct the job pipeline.
the links &lt;code&gt;from&lt;/code&gt; &amp;#8594; &lt;code&gt;to&lt;/code&gt; use the component id and the default input/output branches.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;You can also connect a specific branch of a component if it has multiple or named inputs/outputs branches
using the methods &lt;code&gt;from(id, branchName)&lt;/code&gt; &amp;#8594; &lt;code&gt;to(id, branchName)&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In the example above, the concat component have to inputs (string1 and string2).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;(3) In this step, we validate the job pipeline by asserting that :&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;It has some starting components (component that don&amp;#8217;t have a from connection and that need to be of type producer).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There is no cyclic connections. as the job pipeline need to be an acyclic graph.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;All the components used in connections are already declared.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The connection is used only once. you can&amp;#8217;t connect a component input/output branch twice.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;(4) We run the job pipeline.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
In this version, the execution of the job is linear. the component are not executed in parallel even if some steps
may be independents.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_beam_case"&gt;&lt;a class="anchor" href="#_beam_case"&gt;&lt;/a&gt;5.2. Beam case&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For &lt;a href="https://beam.apache.org/"&gt;beam&lt;/a&gt; case, you need to rely on beam pipeline definition and use &lt;code&gt;component-runtime-beam&lt;/code&gt; dependency which provides Beam bridges.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_i_o"&gt;&lt;a class="anchor" href="#_i_o"&gt;&lt;/a&gt;5.2.1. I/O&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;org.talend.sdk.component.runtime.beam.TalendIO&lt;/code&gt; provides a way to convert a partition mapper or a processor to an input
 or processor
using the &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt; methods.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public class Main {
    public static void main(final String[] args) {
        final ComponentManager manager = ComponentManager.instance()
        Pipeline pipeline = Pipeline.create();
        //Create beam input from mapper and apply input to pipeline
        pipeline.apply(TalendIO.read(manager.findMapper(manager.findMapper("sample", "reader", 1, new HashMap&amp;lt;String, String&amp;gt;() {{
                    put("fileprefix", "input");
                }}).get()))
                .apply(new ViewsMappingTransform(emptyMap(), "sample")) // prepare it for the output record format (see next part)
        //Create beam processor from talend processor and apply to pipeline
                .apply(TalendIO.write(manager.findProcessor("test", "writer", 1, new HashMap&amp;lt;String, String&amp;gt;() {{
                    put("fileprefix", "output");
                }}).get(), emptyMap()));</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>        //... run pipeline
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_processors"&gt;&lt;a class="anchor" href="#_processors"&gt;&lt;/a&gt;5.2.2. Processors&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;org.talend.sdk.component.runtime.beam.TalendFn&lt;/code&gt; provides the way to wrap a processor in a Beam &lt;code&gt;PTransform&lt;/code&gt; and integrate
 it in the pipeline.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public class Main {
    public static void main(final String[] args) {
        //Component manager and pipeline initialization...</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>//Create beam PTransform from processor and apply input to pipeline
pipeline.apply(TalendFn.asFn(manager.findProcessor("sample", "mapper", 1, emptyMap())).get())), emptyMap());</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>        //... run pipeline
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The multiple inputs/outputs are represented by a &lt;code&gt;Map&lt;/code&gt; element in beam case to avoid to use multiple inputs/outputs.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock tip"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-tip" title="Tip"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
you can use &lt;code&gt;ViewsMappingTransform&lt;/code&gt; or &lt;code&gt;CoGroupByKeyResultMappingTransform&lt;/code&gt; to adapt the input/output
format to the record format representing the multiple inputs/output, so a kind of &lt;code&gt;Map&amp;lt;String, List&amp;lt;?&amp;gt;&amp;gt;&lt;/code&gt;,
but materialized as a &lt;code&gt;JsonObject&lt;/code&gt;. Input data must be of type &lt;code&gt;JsonObject&lt;/code&gt; in this case.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_deployment"&gt;&lt;a class="anchor" href="#_deployment"&gt;&lt;/a&gt;5.2.3. Deployment&lt;/h4&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
Beam serializing components it is crucial to add &lt;code&gt;component-runtime-standalone&lt;/code&gt; dependency to the project. It will take
care of providing an implicit and lazy &lt;code&gt;ComponentManager&lt;/code&gt; managing the component in a fatjar case.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_convert_a_beam_io_in_a_component_i_o"&gt;&lt;a class="anchor" href="#_convert_a_beam_io_in_a_component_i_o"&gt;&lt;/a&gt;5.2.4. Convert a Beam.io in a component I/O&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For simple I/O you can get automatic conversion of the Beam.io to a component I/O transparently if you decorated your &lt;code&gt;PTransform&lt;/code&gt;
with &lt;code&gt;@PartitionMapper&lt;/code&gt; or &lt;code&gt;@Processor&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The limitation are:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Inputs must implement &lt;code&gt;PTransform&amp;lt;PBegin, PCollection&amp;lt;?&amp;gt;&amp;gt;&lt;/code&gt; and must be a &lt;code&gt;BoundedSource&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Outputs must implement &lt;code&gt;PTransform&amp;lt;PCollection&amp;lt;?&amp;gt;, PDone&amp;gt;&lt;/code&gt; and just register on the input &lt;code&gt;PCollection&lt;/code&gt; a &lt;code&gt;DoFn&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;More information on that topic on &lt;a href="wrapping-a-beam-io.html" class="page"&gt;How to wrap a Beam I/O&lt;/a&gt; page.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_advanced_define_a_custom_api"&gt;&lt;a class="anchor" href="#_advanced_define_a_custom_api"&gt;&lt;/a&gt;6. Advanced: define a custom API&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is possible to extend the Component API for custom front features.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;What is important here is to keep in mind you should do it
only if it targets not portable components (only used by the Studio or Beam).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In term of organization it is recommanded to create a custom &lt;code&gt;xxxx-component-api&lt;/code&gt; module with the new set of annotations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_extending_the_ui"&gt;&lt;a class="anchor" href="#_extending_the_ui"&gt;&lt;/a&gt;6.1. Extending the UI&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To extend the UI just add an annotation which can be put on &lt;code&gt;@Option&lt;/code&gt; fields which is decorated with &lt;code&gt;@Ui&lt;/code&gt;.
All its members will be put in the metadata of the parameter. Example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Ui
@Target(TYPE)
@Retention(RUNTIME)
public @interface MyLayout {
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>&lt;div class="sect1"&gt;
&lt;h2 id="documentation-testing-start"&gt;&lt;a class="anchor" href="#documentation-testing-start"&gt;&lt;/a&gt;1. Best practises&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="admonitionblock note"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-note" title="Note"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
this part is mainly around tools usable with JUnit. You can use most of these techniques with TestNG
as well, check out the documentation if you need to use TestNG.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_parameterized_tests"&gt;&lt;a class="anchor" href="#_parameterized_tests"&gt;&lt;/a&gt;1.1. Parameterized tests&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This is a great solution to repeat the same test multiple times. Overall idea
is to define a test scenario (&lt;code&gt;I test function F&lt;/code&gt;) and to make the input/output data
dynamic.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_junit_4"&gt;&lt;a class="anchor" href="#_junit_4"&gt;&lt;/a&gt;1.1.1. JUnit 4&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here is an example. Let&#8217;s assume we have this test which validates the connection URI using &lt;code&gt;ConnectionService&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public class MyConnectionURITest {
    @Test
    public void checkMySQL() {
        assertTrue(new ConnectionService().isValid("jdbc:mysql://localhost:3306/mysql"));
    }</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    @Test
    public void checkOracle() {
        assertTrue(new ConnectionService().isValid("jdbc:oracle:thin:@//myhost:1521/oracle"));
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;We clearly identify the test method is always the same except the value. It can therefore be rewritter
using JUnit &lt;code&gt;Parameterized&lt;/code&gt; runner like that:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@RunWith(Parameterized.class) &lt;i class="conum" data-value="1"&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
public class MyConnectionURITest {</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@Parameterized.Parameters(name = "{0}") &lt;i class="conum" data-value="2"&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
public static Iterable&amp;lt;String&amp;gt; uris() { &lt;i class="conum" data-value="3"&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
    return asList(
        "jdbc:mysql://localhost:3306/mysql",
        "jdbc:oracle:thin:@//myhost:1521/oracle");
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@Parameterized.Parameter &lt;i class="conum" data-value="4"&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
public String uri;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    @Test
    public void isValid() { &lt;i class="conum" data-value="5"&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
        assertNotNull(uri);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="colist arabic"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="1"&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Parameterized&lt;/code&gt; is the runner understanding &lt;code&gt;@Parameters&lt;/code&gt; and how to use it. Note that you can generate random data here if desired.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="2"&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;by default the name of the executed test is the index of the data, here we customize it using the first parameter &lt;code&gt;toString()&lt;/code&gt; value to have something more readable&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="3"&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;the &lt;code&gt;@Parameters&lt;/code&gt; method &lt;code&gt;MUST&lt;/code&gt; be static and return an array or iterable of the data used by the tests&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="4"&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;you can then inject the current data using &lt;code&gt;@Parameter&lt;/code&gt; annotation, it can take a parameter if you use an array of array instead of an iterable of object in &lt;code&gt;@Parameterized&lt;/code&gt; and you can select which item you want injected this way&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="5"&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;the &lt;code&gt;@Test&lt;/code&gt; method will be executed using the contextual data, in this sample we&amp;#8217;ll get executed twice with the 2 specified urls&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="admonitionblock tip"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-tip" title="Tip"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
you don&amp;#8217;t have to define a single &lt;code&gt;@Test&lt;/code&gt; method, if you define multiple, each of them will be executed with all the data (ie if we add a test in previous example you will get 4 tests execution - 2 per data, ie 2x2)
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_junit_5"&gt;&lt;a class="anchor" href="#_junit_5"&gt;&lt;/a&gt;1.1.2. JUnit 5&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;JUnit 5 reworked this feature to make it way easier to use. The full documentation is available at &lt;a href="http://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests" class="bare"&gt;junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The main difference is you can also define inline on the test method that it is a parameterized test and which are the values:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@ParameterizedTest
@ValueSource(strings = { "racecar", "radar", "able was I ere I saw elba" })
void mytest(String currentValue) {
    // do test
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;However you can still use the previous behavior using a method binding configuration:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@ParameterizedTest
@MethodSource("stringProvider")
void mytest(String currentValue) {
    // do test
}</pre>
</div>
</div>
<div class="paragraph">
<p>static Stream&lt;String&gt; stringProvider() {
    return Stream.of("foo", "bar");
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This last option allows you to inject any type of value - not only primitives - which is very common to define scenarii.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
don&#8217;t forget to add &lt;code&gt;junit-jupiter-params&lt;/code&gt; dependency to benefit from this feature.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_component_runtime_testing"&gt;&lt;a class="anchor" href="#_component_runtime_testing"&gt;&lt;/a&gt;2. component-runtime-testing&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_component_runtime_junit"&gt;&lt;a class="anchor" href="#_component_runtime_junit"&gt;&lt;/a&gt;2.1. component-runtime-junit&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;component-runtime-junit&lt;/code&gt; is a small test library allowing you to validate simple logic based on Talend Component tooling.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To import it add to your project the following dependency:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&lt;dependency&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;component-runtime-junit&lt;/artifactId&gt;
  &lt;version&gt;${talend-component.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This dependency also provide some mocked components that you can use with your own component to create tests.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The mocked components are provided under the family &lt;code&gt;test&lt;/code&gt; :&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;emitter&lt;/code&gt;     : a mock of an input component&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;collector&lt;/code&gt;   : a mock of an output component&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_junit_4_2"&gt;&lt;a class="anchor" href="#_junit_4_2"&gt;&lt;/a&gt;2.1.1. JUnit 4&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Then you can define a standard JUnit test and use the &lt;code&gt;SimpleComponentRule&lt;/code&gt; rule:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public class MyComponentTest {</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@Rule &lt;i class="conum" data-value="1"&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
public final SimpleComponentRule components = new SimpleComponentRule("org.talend.sdk.component.mycomponent.");</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@Test
public void produce() {
    Job.components() &lt;i class="conum" data-value="2"&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
         .component("mycomponent","yourcomponentfamily://yourcomponent?"+createComponentConfig())
         .component("collector", "test://collector")
       .connections()
         .from("mycomponent").to("collector")
       .build()
       .run();</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>        final List&amp;lt;MyRecord&amp;gt; records = components.getCollectedData(MyRecord.class); &lt;i class="conum" data-value="3"&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
        doAssertRecords(records); // depending your test
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="colist arabic"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="1"&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;the rule will create a component manager and provide two mock components: an emitter and a collector. Don&amp;#8217;t forget to set the root package of your component to enable it.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="2"&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;you define any chain you want to test, it generally uses the mock as source or collector&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="3"&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;you validate your component behavior, for a source you can assert the right records were emitted in the mock collect&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_junit_5_2"&gt;&lt;a class="anchor" href="#_junit_5_2"&gt;&lt;/a&gt;2.1.2. JUnit 5&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The JUnit 5 integration is mainly the same as for JUnit 4 except it uses the new JUnit 5 extension mecanism.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The entry point is the &lt;code&gt;@WithComponents&lt;/code&gt; annotation you put on your test class which takes the
component package you want to test and you can use &lt;code&gt;@Injected&lt;/code&gt; to inject in a test class field an instance of &lt;code&gt;ComponentsHandler&lt;/code&gt;
which exposes the same utilities than the JUnit 4 rule:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@WithComponents("org.talend.sdk.component.junit.component") &lt;i class="conum" data-value="1"&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
public class ComponentExtensionTest {
    @Injected &lt;i class="conum" data-value="2"&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
    private ComponentsHandler handler;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@Test
public void manualMapper() {
    final Mapper mapper = handler.createMapper(Source.class, new Source.Config() {</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>            {
                values = asList("a", "b");
            }
        });
        assertFalse(mapper.isStream());
        final Input input = mapper.create();
        assertEquals("a", input.next());
        assertEquals("b", input.next());
        assertNull(input.next());
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="colist arabic"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="1"&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;The annotation defines which components to register in the test context.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="2"&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;The field allows to get the handler to be able to orchestrate the tests.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="admonitionblock note"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-note" title="Note"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
if it is the first time you use JUnit 5, don&amp;#8217;t forget the imports changed and you must use &lt;code&gt;org.junit.jupiter.api.Test&lt;/code&gt; instead of &lt;code&gt;org.junit.Test&lt;/code&gt;.
Some IDE versions and &lt;code&gt;surefire&lt;/code&gt; versions can also need you to install either a plugin or a specific configuration.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_mocking_the_output"&gt;&lt;a class="anchor" href="#_mocking_the_output"&gt;&lt;/a&gt;2.1.3. Mocking the output&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Using the component "test"/"collector" as in previous sample stores all records emitted by the chain (typically your source)
in memory, you can then access them using &lt;code&gt;theSimpleComponentRule.getCollectoedRecord(type)&lt;/code&gt;. Note that this method filters by type,
if you don&amp;#8217;t care of the type just use &lt;code&gt;Object.class&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_mocking_the_input"&gt;&lt;a class="anchor" href="#_mocking_the_input"&gt;&lt;/a&gt;2.1.4. Mocking the input&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The input mocking is symmetric to the output but here you provide the data you want to inject:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public class MyComponentTest {</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@Rule
public final SimpleComponentRule components = new SimpleComponentRule("org.talend.sdk.component.mycomponent.");</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@Test
public void produce() {
    components.setInputData(asList(createData(), createData(), createData())); &lt;i class="conum" data-value="1"&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Job.components() &lt;i class="conum" data-value="2"&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
     .component("emitter","test://emitter")
     .component("out", "yourcomponentfamily://myoutput?"+createComponentConfig())
   .connections()
      .from("emitter").to("out")
   .build
   .run();</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>        assertMyOutputProcessedTheInputData();
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="colist arabic"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class="conum" data-value="1"&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;using &lt;code&gt;setInputData&lt;/code&gt; you prepare the execution(s) to have a fake input when using "test"/"emitter" component.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_creating_runtime_configuration_from_component_configuration"&gt;&lt;a class="anchor" href="#_creating_runtime_configuration_from_component_configuration"&gt;&lt;/a&gt;2.1.5. Creating runtime configuration from component configuration&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The component configuration is a POJO (using &lt;code&gt;@Option&lt;/code&gt; on fields) and the runtime configuration (&lt;code&gt;ExecutionChainBuilder&lt;/code&gt;) uses
a &lt;code&gt;Map&amp;lt;String, String&amp;gt;&lt;/code&gt;. To make the conversion easier, the JUnit integration provides a &lt;code&gt;SimpleFactory.configurationByExample&lt;/code&gt; utility
to get this map instance from a configuration instance.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;final MyComponentConfig componentConfig = new MyComponentConfig();
componentConfig.setUser("....");
// .. other inits</pre>
</div>
</div>
<div class="paragraph">
<p>final Map&lt;String, String&gt; configuration = configurationByExample(componentConfig);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_testing_a_mapper"&gt;&lt;a class="anchor" href="#_testing_a_mapper"&gt;&lt;/a&gt;2.1.6. Testing a Mapper&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The &lt;code&gt;SimpleComponentRule&lt;/code&gt; also allows to test a mapper unitarly, you can get an instance from a configuration
and you can execute this instance to collect the output. Here is a snippet doing that:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public class MapperTest {</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@ClassRule
public static final SimpleComponentRule COMPONENT_FACTORY = new SimpleComponentRule(
        "org.company.talend.component");</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    @Test
    public void mapper() {
        final Mapper mapper = COMPONENT_FACTORY.createMapper(MyMapper.class, new Source.Config() {{
            values = asList("a", "b");
        }});
        assertEquals(asList("a", "b"), COMPONENT_FACTORY.collectAsList(String.class, mapper));
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_testing_a_processor"&gt;&lt;a class="anchor" href="#_testing_a_processor"&gt;&lt;/a&gt;2.1.7. Testing a Processor&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;As for the mapper a processor is testable unitary. The case is a bit more complex since you can have multiple
inputs and outputs:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public class ProcessorTest {</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@ClassRule
public static final SimpleComponentRule COMPONENT_FACTORY = new SimpleComponentRule(
        "org.company.talend.component");</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    @Test
    public void processor() {
        final Processor processor = COMPONENT_FACTORY.createProcessor(Transform.class, null);
        final SimpleComponentRule.Outputs outputs = COMPONENT_FACTORY.collect(processor,
                        new JoinInputFactory().withInput("__default__", asList(new Transform.Record("a"), new Transform.Record("bb")))
                                              .withInput("second", asList(new Transform.Record("1"), new Transform.Record("2")))
                );
        assertEquals(2, outputs.size());
        assertEquals(asList(2, 3), outputs.get(Integer.class, "size"));
        assertEquals(asList("a1", "bb2"), outputs.get(String.class, "value"));
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here again the rule allows you to instantiate a &lt;code&gt;Processor&lt;/code&gt; from your code
and then to &lt;code&gt;collect&lt;/code&gt; the output from the inputs you pass in. There are two convenient implementation
of the input factory:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="olist arabic"&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MainInputFactory&lt;/code&gt; for processors using only the default input.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JoinInputfactory&lt;/code&gt; for processors using multiple inputs have a method &lt;code&gt;withInput(branch, data)&lt;/code&gt; The first arg is the branch name
and the second arg is the data used by the branch.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="admonitionblock tip"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-tip" title="Tip"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
you can also implement your own input representation if needed implementing &lt;code&gt;org.talend.sdk.component.junit.ControllableInputFactory&lt;/code&gt;.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_component_runtime_testing_spark"&gt;&lt;a class="anchor" href="#_component_runtime_testing_spark"&gt;&lt;/a&gt;2.2. component-runtime-testing-spark&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The folowing artifact will allow you to test against a spark cluster:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.talend.sdk.component&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;component-runtime-testing-spark&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;${talend-component.version}&amp;lt;/version&amp;gt;
  &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_junit_4_3"&gt;&lt;a class="anchor" href="#_junit_4_3"&gt;&lt;/a&gt;2.2.1. JUnit 4&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The usage relies on a JUnit &lt;code&gt;TestRule&lt;/code&gt;. It is recommanded to use it as a &lt;code&gt;@ClassRule&lt;/code&gt; to ensure
a single instance of a spark cluster is built but you can also use it as a simple &lt;code&gt;@Rule&lt;/code&gt; which means
it will be created per method instead of per test class.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It takes as parameter the spark and scala version to use. It will then fork a master and N slaves.
Finally it will give you &lt;code&gt;submit*&lt;/code&gt; method allowing you to send jobs either from the test classpath
or from a shade if you run it as an integration test.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here is a sample:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public class SparkClusterRuleTest {</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@ClassRule
public static final SparkClusterRule SPARK = new SparkClusterRule("2.10", "1.6.3", 1);</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@Test
public void classpathSubmit() throws IOException {
    SPARK.submitClasspath(SubmittableMain.class, getMainArgs());</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>        // do wait the test passed
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="admonitionblock tip"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-tip" title="Tip"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
this is working with &lt;code&gt;@Parameterized&lt;/code&gt; so you can submit a bunch of jobs with different args and even combine it with beam &lt;code&gt;TestPipeline&lt;/code&gt; if you make it &lt;code&gt;transient&lt;/code&gt;!
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_junit_5_3"&gt;&lt;a class="anchor" href="#_junit_5_3"&gt;&lt;/a&gt;2.2.2. JUnit 5&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The integration with JUnit 5 of that spark cluster logic uses &lt;code&gt;@WithSpark&lt;/code&gt; marker for the extension
and let you, optionally, inject through &lt;code&gt;@SparkInject&lt;/code&gt;, the &lt;code&gt;BaseSpark&amp;lt;?&amp;gt;&lt;/code&gt; handler to access te spark cluster
meta information - like its host/port.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here is a basic test using it:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@WithSpark
class SparkExtensionTest {</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@SparkInject
private BaseSpark&amp;lt;?&amp;gt; spark;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@Test
void classpathSubmit() throws IOException {
    final File out = new File(jarLocation(SparkClusterRuleTest.class).getParentFile(), "classpathSubmitJunit5.out");
    if (out.exists()) {
        out.delete();
    }
    spark.submitClasspath(SparkClusterRuleTest.SubmittableMain.class, spark.getSparkMaster(), out.getAbsolutePath());</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>        await().atMost(5, MINUTES).until(
                () -&amp;gt; out.exists() ? Files.readAllLines(out.toPath()).stream().collect(joining("\n")).trim() : null,
                equalTo("b -&amp;gt; 1\na -&amp;gt; 1"));
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_how_to_know_the_job_is_done"&gt;&lt;a class="anchor" href="#_how_to_know_the_job_is_done"&gt;&lt;/a&gt;2.2.3. How to know the job is done&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In current state, &lt;code&gt;SparkClusterRule&lt;/code&gt; doesn&amp;#8217;t allow to know a job execution is done - even if it exposes the webui url so
you can poll it to check. The best at the moment is to ensure the output of your job exists and contains the right value.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;code&gt;awaitability&lt;/code&gt; or equivalent library can help you to write such logic.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here are the coordinates of the artifact:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.awaitility&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;awaitility&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;3.0.0&amp;lt;/version&amp;gt;
  &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;And here is how to wait a file exists and its content (for instance) is the expected one:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;await()
    .atMost(5, MINUTES)
    .until(
        () -&amp;gt; out.exists() ? Files.readAllLines(out.toPath()).stream().collect(joining("\n")).trim() : null,
        equalTo("the expected content of the file"));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_component_runtime_http_junit"&gt;&lt;a class="anchor" href="#_component_runtime_http_junit"&gt;&lt;/a&gt;2.3. component-runtime-http-junit&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The HTTP JUnit module allows you to mock REST API very easily. Here are its coordinates:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-xml hljs" data-lang="xml"&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.talend.sdk.component&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;component-runtime-junit&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;${talend-component.version}&amp;lt;/version&amp;gt;
  &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="admonitionblock tip"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-tip" title="Tip"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
this module uses Apache Johnzon and Netty, if you have any conflict (in particular with netty) you can add the classifier &lt;code&gt;shaded&lt;/code&gt;
to the dependency and the two dependencies are shaded avoiding the conflicts with your component.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It supports JUnit 4 and JUnit 5 as well but the overall concept is the exact same one: the extension/rule
is able to serve precomputed responses saved in the classpath.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;You can plug your own &lt;code&gt;ResponseLocator&lt;/code&gt; to map a request to a response but the default implementation - which should be sufficient
in most cases - will look in &lt;code&gt;talend/testing/http/&amp;lt;class name&amp;gt;_&amp;lt;method name&amp;gt;.json&lt;/code&gt;. Note that you can also put it
in &lt;code&gt;talend/testing/http/&amp;lt;request path&amp;gt;.json&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_junit_4_4"&gt;&lt;a class="anchor" href="#_junit_4_4"&gt;&lt;/a&gt;2.3.1. JUnit 4&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;JUnit 4 setup is done through two rules: &lt;code&gt;JUnit4HttpApi&lt;/code&gt; which is responsible to start the server and &lt;code&gt;JUnit4HttpApiPerMethodConfigurator&lt;/code&gt;
which is responsible to configure the server per test and also handle the capture mode (see later).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
if you don&amp;#8217;t use the &lt;code&gt;JUnit4HttpApiPerMethodConfigurator&lt;/code&gt;, the capture feature will be deactivated and the per test mocking will not be available.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Most of the test will look like:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public class MyRESTApiTest {
    @ClassRule
    public static final JUnit4HttpApi API = new JUnit4HttpApi();</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@Rule
public final JUnit4HttpApiPerMethodConfigurator configurator = new JUnit4HttpApiPerMethodConfigurator(API);</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    @Test
    public void direct() throws Exception {
        // ... do your requests
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect4"&gt;
&lt;h5 id="_ssl"&gt;&lt;a class="anchor" href="#_ssl"&gt;&lt;/a&gt;SSL&lt;/h5&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For tests using SSL based services, you will need to use &lt;code&gt;activeSsl()&lt;/code&gt; on the &lt;code&gt;JUnit4HttpApi&lt;/code&gt; rule.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If you need to access the server ssl socket factory you can do it from the &lt;code&gt;HttpApiHandler&lt;/code&gt; (the rule):&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@ClassRule
public static final JUnit4HttpApi API = new JUnit4HttpApi()&lt;strong&gt;.activeSsl()&lt;/strong&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>@Test
public void test() throws Exception {
    final HttpsURLConnection connection = getHttpsConnection();
    connection.setSSLSocketFactory(API.getSslContext().getSocketFactory());
    // &#8230;&#8203;.
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_junit_5_4"&gt;&lt;a class="anchor" href="#_junit_5_4"&gt;&lt;/a&gt;2.3.2. JUnit 5&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;JUnit 5 uses a JUnit 5 extension based on the &lt;code&gt;HttpApi&lt;/code&gt; annotation you can put on your test class. You can inject
the test handler (which has some utilities for advanced cases) through &lt;code&gt;@HttpApiInject&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@HttpApi
class JUnit5HttpApiTest {
    @HttpApiInject
    private HttpApiHandler&lt;?&gt; handler;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    @Test
    void getProxy() throws Exception {
        // .... do your requests
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="admonitionblock note"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-note" title="Note"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
the injection is optional and the &lt;code&gt;@HttpApi&lt;/code&gt; allows you to configure several behaviors of the test.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="sect4"&gt;
&lt;h5 id="_ssl_2"&gt;&lt;a class="anchor" href="#_ssl_2"&gt;&lt;/a&gt;SSL&lt;/h5&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For tests using SSL based services, you will need to use &lt;code&gt;@HttpApi(useSsl = true)&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;You can access the client SSL socket factory through the api handler:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@HttpApi*(useSsl = true)*
class MyHttpsApiTest {
    @HttpApiInject
    private HttpApiHandler&amp;lt;?&amp;gt; handler;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    @Test
    void test() throws Exception {
        final HttpsURLConnection connection = getHttpsConnection();
        connection.setSSLSocketFactory(handler.getSslContext().getSocketFactory());
        // ....
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_capturing_mode"&gt;&lt;a class="anchor" href="#_capturing_mode"&gt;&lt;/a&gt;2.3.3. Capturing mode&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The strength of this implementation is to run a small proxy server and auto configure the JVM:
&lt;code&gt;http[s].proxyHost&lt;/code&gt;, &lt;code&gt;http[s].proxyPort&lt;/code&gt;, &lt;code&gt;HttpsURLConnection#defaultSSLSocketFactory&lt;/code&gt; and &lt;code&gt;SSLContext#default&lt;/code&gt;
are auto configured to work out of the box with the proxy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It allows you to keep in your tests the native and real URLs. For instance this test is perfectlt valid:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;public class GoogleTest {
    @ClassRule
    public static final JUnit4HttpApi API = new JUnit4HttpApi();</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@Rule
public final JUnit4HttpApiPerMethodConfigurator configurator = new JUnit4HttpApiPerMethodConfigurator(API);</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@Test
public void google() throws Exception {
    assertEquals(HttpURLConnection.HTTP_OK, get("https://google.fr?q=Talend"));
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    private int get(final String uri) throws Exception {
        // do the GET request, skipped for brievity
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If you execute this test, it will fail with a HTTP 400 because the proxy doesn&amp;#8217;t find the mocked response.
You can create it manually as seen in the introduction of the module but you can also set the property &lt;code&gt;talend.junit.http.capture&lt;/code&gt;
to the folder where to store the captures. It must be the root folder and not the folder where the json are (ie not prefixed by &lt;code&gt;talend/testing/http&lt;/code&gt; by default).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Generally you will want to use &lt;code&gt;src/test/resources&lt;/code&gt;. If &lt;code&gt;new File("src/test/resources")&lt;/code&gt; resolves to the valid folder when executing your test (Maven default),
then you can just set the system property to true, otherwise you need to adjust accordingly the system property value.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Once you ran the tests with this system property, the testing framework will have created the correct mock response files and you can
remove the system property. The test will still pass, using &lt;code&gt;google.com&lt;/code&gt;&amp;#8230;&amp;#8203;even if you disconnect your machine from the internet.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The rule (extension) is doing all the work for you :).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_passthrough_mode"&gt;&lt;a class="anchor" href="#_passthrough_mode"&gt;&lt;/a&gt;2.3.4. Passthrough mode&lt;/h4&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Setting &lt;code&gt;talend.junit.http.passthrough&lt;/code&gt; system property to &lt;code&gt;true&lt;/code&gt;, the server will just be a proxy and will execute each request
to the actual server - like in capturing mode.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_beam_testing"&gt;&lt;a class="anchor" href="#_beam_testing"&gt;&lt;/a&gt;3. Beam testing&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If you want to ensure your component works in Beam the minimum to do is to try with the direct runner (if you don&amp;#8217;t want to use spark).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Check &lt;a href="https://beam.apache.org/contribute/testing/" class="bare"&gt;beam.apache.org/contribute/testing/&lt;/a&gt; out for more details.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_multiple_environments_for_the_same_tests"&gt;&lt;a class="anchor" href="#_multiple_environments_for_the_same_tests"&gt;&lt;/a&gt;4. Multiple environments for the same tests&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;JUnit (4 or 5) already provides some ways to parameterized tests and execute the same "test logic"
against several data. However it is not that convenient to test multiple environments.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;For instance, with Beam, you can desire to test against multiple runners your code
and it requires to solve conflicts between runner dependencies, setup the correct classloaders
etc&amp;#8230;&amp;#8203;It is a lot of work!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To simplify such cases, the framework provides you a multi-environment support for your tests.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is in the junit module and is usable with JUnit 4 and JUnit 5.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_junit_4_5"&gt;&lt;a class="anchor" href="#_junit_4_5"&gt;&lt;/a&gt;4.1. JUnit 4&lt;/h3&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@RunWith(MultiEnvironmentsRunner.class)
@Environment(Env1.class)
@Environment(Env1.class)
public class TheTest {
    @Test
    public void test1() {
        // ...
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The &lt;code&gt;MultiEnvironmentsRunner&lt;/code&gt; will execute the test(s) for each defined environments. It means it will
run &lt;code&gt;test1&lt;/code&gt; for &lt;code&gt;Env1&lt;/code&gt; and &lt;code&gt;Env2&lt;/code&gt; in previous example.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;By default &lt;code&gt;JUnit4&lt;/code&gt; runner will be used to execute the tests in one environment but you can use &lt;code&gt;@DelegateRunWith&lt;/code&gt;
to use another runner.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_junit_5_5"&gt;&lt;a class="anchor" href="#_junit_5_5"&gt;&lt;/a&gt;4.2. JUnit 5&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;JUnit 5 configuration is close to JUnit 4 one:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Environment(EnvironmentsExtensionTest.E1.class)
@Environment(EnvironmentsExtensionTest.E2.class)
class TheTest {</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    @EnvironmentalTest
    void test1() {
        // ...
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The main difference is you don&amp;#8217;t use a runner (it doesn&amp;#8217;t exist in JUnit 5) and you replace &lt;code&gt;@Test&lt;/code&gt; by &lt;code&gt;@EnvironmentalTest&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock important"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-important" title="Important"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
the main difference with JUnit 4 integration is that the tests are execute one after each other for all environments
instead of running all tests in each environments sequentially. It means, for instance, that &lt;code&gt;@BeforeAll&lt;/code&gt; and &lt;code&gt;@AfterAll&lt;/code&gt; are executed
once for all runners.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_provided_environments"&gt;&lt;a class="anchor" href="#_provided_environments"&gt;&lt;/a&gt;4.3. Provided environments&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The provided environment setup the contextual classloader to load the related runner of Apache Beam.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Package: &lt;code&gt;org.talend.sdk.component.junit.environment.builtin.beam&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock note"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-note" title="Note"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
the configuration is read from system properties, environment variables, &amp;#8230;&amp;#8203;.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;table class="tableblock frame-all grid-all table-striped table-hover table-ordered"&gt;
&lt;colgroup&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Class&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Name&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;ContextualEnvironment&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Contextual&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Contextual runner&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;DirectRunnerEnvironment&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Direct&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Direct runner&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;FlinkRunnerEnvironment&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Flink&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Flink runner&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;SparkRunnerEnvironment&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Spark&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;Spark runner&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_configuring_environments"&gt;&lt;a class="anchor" href="#_configuring_environments"&gt;&lt;/a&gt;4.4. Configuring environments&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If the environment extends &lt;code&gt;BaseEnvironmentProvider&lt;/code&gt; and therefore defines an environment name - which is the case of the default ones, you can use &lt;code&gt;EnvironmentConfiguration&lt;/code&gt;
to customize the system properties used for that environment:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Environment(DirectRunnerEnvironment.class)
@EnvironmentConfiguration(
    environment = "Direct",
    systemProperties = @EnvironmentConfiguration.Property(key = "beamTestPipelineOptions", value = "..."))</pre>
</div>
</div>
<div class="paragraph">
<p>@Environment(SparkRunnerEnvironment.class)
@EnvironmentConfiguration(
    environment = "Spark",
    systemProperties = @EnvironmentConfiguration.Property(key = "beamTestPipelineOptions", value = "&#8230;&#8203;"))</p>
</div>
<div class="paragraph">
<p>@Environment(FlinkRunnerEnvironment.class)
@EnvironmentConfiguration(
    environment = "Flink",
    systemProperties = @EnvironmentConfiguration.Property(key = "beamTestPipelineOptions", value = "&#8230;&#8203;"))
class MyBeamTest {</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    @EnvironmentalTest
    void execute() {
        // run some pipeline
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="admonitionblock tip"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-tip" title="Tip"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
if you set the system property &lt;code&gt;&amp;lt;environment name&amp;gt;.skip=true&lt;/code&gt; then the environment related executions will be skipped.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="sect3"&gt;
&lt;h4 id="_advanced_usage"&gt;&lt;a class="anchor" href="#_advanced_usage"&gt;&lt;/a&gt;4.4.1. Advanced usage&lt;/h4&gt;
&lt;div class="admonitionblock warning"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-warning" title="Warning"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
this usage assumes Beam 2.4.0 is in used and the classloader fix about the &lt;code&gt;PipelineOptions&lt;/code&gt; is merged.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Dependencies:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;&amp;lt;dependencies&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.talend.sdk.component&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;component-runtime-junit&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.junit.jupiter&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junit-jupiter-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.jboss.shrinkwrap.resolver&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;shrinkwrap-resolver-impl-maven&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.0.1&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.talend.sdk.component&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;component-runtime-beam&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.talend.sdk.component&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;component-runtime-standalone&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;These dependencies brings into the test scope the JUnit testing toolkit,
the Beam integration and the multi-environment testing toolkit for JUnit.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Then using the fluent DSL to define jobs - which assumes your job is linear and
each step sends a single value (no multi-input/multi-output), you can write this kind of test:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;@Environment(ContextualEnvironment.class)
@Environment(DirectRunnerEnvironment.class)
class TheComponentTest {
    @EnvironmentalTest
    void testWithStandaloneAndBeamEnvironments() {
        from("myfamily://in?config=xxxx")
            .to("myfamily://out")
            .create()
            .execute();
        // add asserts on the output if needed
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It will execute the chain twice:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="olist arabic"&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;
&lt;p&gt;with a standalone environment to simulate the studio&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;with a beam (direct runner) environment to ensure the portability of your job&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_secrets_passwords_and_maven"&gt;&lt;a class="anchor" href="#_secrets_passwords_and_maven"&gt;&lt;/a&gt;5. Secrets/Passwords and Maven&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If you desire you can reuse your Maven &lt;code&gt;settings.xml&lt;/code&gt; servers - including the encrypted ones.
&lt;code&gt;org.talend.sdk.component.maven.MavenDecrypter&lt;/code&gt; will give you the ability to find a server &lt;code&gt;username&lt;/code&gt;/&lt;code&gt;password&lt;/code&gt; from
a server identifier:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlightjs highlight"&gt;&lt;code class="language-java hljs" data-lang="java"&gt;final MavenDecrypter decrypter = new MavenDecrypter();
final Server decrypted = decrypter.find("my-test-server");
// decrypted.getUsername();
// decrypted.getPassword();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is very useful to not store secrets and test on real systems on a continuous integration platform.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock tip"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-tip" title="Tip"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
even if you don&amp;#8217;t use maven on the platform you can generate the &lt;code&gt;settings.xml&lt;/code&gt; and &lt;code&gt;settings-security.xml&lt;/code&gt; files
to use that feature. See &lt;a href="https://maven.apache.org/guides/mini/guide-encryption.html" class="bare"&gt;maven.apache.org/guides/mini/guide-encryption.html&lt;/a&gt; for more details.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_generating_data"&gt;&lt;a class="anchor" href="#_generating_data"&gt;&lt;/a&gt;6. Generating data?&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Several data generator exists if you want to populate objects with a semantic a bit more evolved than a plain random string
like &lt;code&gt;commons-lang3&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/Codearte/jfairy" class="bare"&gt;github.com/Codearte/jfairy&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/DiUS/java-faker" class="bare"&gt;github.com/DiUS/java-faker&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/andygibson/datafactory" class="bare"&gt;github.com/andygibson/datafactory&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A bit more advanced, these ones allow to bind directly generic data on a model - but data quality is not always there:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/devopsfolks/podam" class="bare"&gt;github.com/devopsfolks/podam&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/benas/random-beans" class="bare"&gt;github.com/benas/random-beans&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Note there are two main kind of implementations:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the one using a &lt;em&gt;pattern&lt;/em&gt; and random generated data&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a set of precomputed data extrapolated to create new values&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Check against your use case to know which one is the best.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonitionblock note"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class="icon"&gt;
&lt;i class="fa icon-note" title="Note"&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class="content"&gt;
an interesting alternative to data generation is to import &lt;em&gt;real&lt;/em&gt; data and use Talend Studio to sanitize the data (remove sensitive information replacing them by generated data or anonymized data)
and just inject that file into the system.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If you are using JUnit 5, you can have a look to &lt;a href="https://glytching.github.io/junit-extensions/randomBeans" class="bare"&gt;glytching.github.io/junit-extensions/randomBeans&lt;/a&gt;
which is pretty good on that topic.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</pre>
</div>
</div>
    </article>
  </main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../_/js/site.js"></script>
<script src="../../_/js/vendor/highlight.js"></script>
<script>hljs.initHighlighting()</script>
  </body>
</html>
